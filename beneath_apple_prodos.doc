<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="http://www.nongnu.org/elyxer/">
<meta name="create-date" content="2018-05-27">
<link rel="stylesheet" href="http://elyxer.nongnu.org/lyx.css" type="text/css" media="all">
<title>Beneath Apple ProDOS</title>
</head>
<body>
<div id="globalWrapper">
<h1 class="title">
Beneath Apple ProDOS
</h1>
<h2 class="author">
Don D. Worth and Pieter M. Lechner
</h2>
<h2 class="Date">
March 1985
</h2>
<div class="Unindented">
<div class="center">
This book is dedicated to my sister, Betsy, who said she had room on her bookshelf for another one of my books.
</div>

</div>
<div class="Indented">
<div class="center">
Don D. Worth<br>

</div>

</div>
<div class="Indented">
<div class="center">
This book is dedicated to my Father and Mother, with a deep sense of appreciation and gratitude.
</div>

</div>
<div class="Indented">
<div class="center">
Pieter M. Lechner
</div>

</div>
<div class="fulltoc">
<div class="tocheader">
Table of Contents
</div>
<div class="tocindent">
<div class="toc">
<a class="Link" href="#toc-Chapter-1">Chapter 1: Introduction</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-2">Chapter 2: To Build A Better DOS</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-3">Chapter 3: Disk II Hardware And Diskette Formatting</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-4">Chapter 4: Volumes, Directories, And Files</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-5">Chapter 5: The Structure Of ProDOS</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-6">Chapter 6: Using ProDOS From Assembly Language</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-7">Chapter 7: Customizing ProDOS</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Chapter-8">Chapter 8: ProDOS Global Pages</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-A">Appendix A: Example Programs</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-B">Appendix B: Diskette Protection Schemes</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-C">Appendix C: Nibbilizing</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-D">Appendix D: The Logic State Sequencer</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-E">Appendix E: ProDOS, DOS, And SOS</a>
</div>
<div class="toc">
<a class="Link" href="#toc-Appendix-F">Appendix F: Glossary</a>
</div>
</div>

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-1">1</a> Introduction
</h1>
<div class="Unindented">
<i>Beneath Apple ProDOS</i> is intended to serve as a companion to the manuals provided by Apple Computer, Inc. for ProDOS, providing additional information for the advanced programmer or for the novice Apple user who wants too know more about the structure of disks. It is not the intent of this manual to replace the documentation provided by Apple. Although, for the sake of continuity, some of the material covered in the Apple manuals is also covered here, it will be assumed that the reader is reasonably familiar with the contents of Apple’s <i>ProDOS User’s Manual</i> and <i>BASIC Programming With ProDOS</i>. Since all chapters presented here may not be of use to each Apple owner, each has been written to stand on its own. Readers of out earlier book, <i>Beneath Apple DOS</i>, will notice that we have retained the basic organization of that book in an attempt to help them familiarize themselves with <i>Beneath Apple ProDOS</i> more quickly.
</div>
<div class="Indented">
The information presented here is a result of intensive disassembly and annotation of various versions of ProDOS by the authors. It also uses as a reference various applications notes and preliminary documentation from Apple. Although not guarantee can be made concerning the accuracy of the information presented here, all of the material included in <i>Beneath Apple ProDOS</i> has been thoroughly researched and tested.
</div>
<div class="Indented">
There were several reasons for writing <i>Beneath Apple ProDOS</i>:
</div>
<ul>
<li>
To Show how to access ProDOS and/or the Disk II drive directly from machine language.
</li>
<li>
To help you fix damaged disks.
</li>
<li>
To correct errors and omissions in the Apple documentation.
</li>
<li>
To allow you to customize ProDOS to fit your needs.
</li>
<li>
To provide complete information on the diskette formatting.
</li>
<li>
To document the internal logic of ProDOS.
</li>
<li>
To present a critical, non-Apple perspective of ProDOS.
</li>
<li>
To provide more examples of ProDOS programming.
</li>
<li>
To help you learn about how an operating system works.
</li>

</ul>
<div class="Unindented">
When Apple introduced ProDOS Version 1.0.1 in January 1984, three manuals were available: the <i>ProDOS User’s Manual</i> documents the use of ProDOS utilities; the <i>BASIC Programming With ProDOS</i> manual describes the command language supported by the BASIC Interpreter and how to write BASIC programs which access the disk; and the <i>ProDOS Technical Reference Manual (for the Apple II family)</i> documents the assembly language interfaces to ProDOS. It should be stated that this technical reference manual represents the best internal documentation Apple has ever provided to users of one of their operating systems. Unfortunately, the <i>ProDOS Technical Reference Manual</i> documents a prerelease version of ProDOS, and is not entirely accurate for the current release at the time of this writing. In addition, many sections require further explanation before the interfaces they describe can be used at all. For example, the discussion of how one adds a command to the BASIC interpreter omits several vital pieces of information which are documented fully in <i>Beneath Apple ProDOS</i>. In addition, none of the Apple documentation addresses diskette formatting or direct access of the Disk II family of controllers from assembly language. <i>Beneath Apple ProDOS</i> was written in an attempt to improve upon the documentation base established by Apple. Most of the topics covered by Apple’s technical manual are covered bere also, but they are explained in a different and, we hope, clearer way, based upon a programmer’s understanding of the code in the ProDOS Kernel and the BASIC Interpreter. We have also added substantial information on diskette formatting and repair, the internal logic and structure of ProDOS, and customizing techniques, as well as providing several example programs and quick reference materials. 
</div>
<div class="Indented">
In addition to the ProDOS specific information provided, many of the discussions also apply to other operating systems in the Apple II nd Apple III family of machines. For example, disk formatting at the track and sector level is for the most part the same. Also, the format of a ProDOS volume is nearly identical to that of an Apple III SOS volume.
</div>
<div class="Indented">
For those readers who would like to have a detailed description of every bit of code in the current version of ProDOS, a supplement to this book is available and can be ordered directly from Quality Software. Please see Chapter 8 for details. 
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-2">2</a> To Build A Better DOS
</h1>
<div class="Unindented">
From June 1978 to January 1984, the primary disk operating system for the Apple II family as Apple DOS. Throughout its first six years of existence, DOS has gone through a number of changes, culminating in its final version, DOS 3.3. DOS as originally designed primarily to support the BASIC programmer, but has since been adopted by assembly language programmers and by the majority of Apple users for a variety of applications.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-2.1">2.1</a> The Deficiencies of DOS
</h2>
<div class="Unindented">
Although it is a flexible and easy to use operating system, DOS suffers from many weaknesses. Among them are these:
</div>
<ul>
<li>
<b>DOS is slow.</b> Since each byte read from the disk is copied between memory buffers up to three times, a large portion of the actual overhead in reading data from the disk is in processor manipulation after the data has been read. To circumvent this, several &ldquo;fast DOS&rdquo; packages have been marketed by third parties which heavily modify DOS to prevent multiple buffering under certain circumstances.
</li>
<li>
<b>DOS is device dependent.</b> When DOS was developed, the only mass storage device for the Apple was the Disk II diskette drive. Now that diskette drives with increased capacity and hard disks are available, a more device independent file organization is needed. DOS is limited in the number of files which can be stored on a diskette as well as their maximum size. These are significant drawbacks when a hard disk with five million bytes or more is used.
</li>
<li>
Over the years, new hardware has been introduced by Apple and other manufacturers which DOS does not intrinsically support. The Apple IIe with its 80-column card and the Thunderclock are examples.
</li>
<li>
<b>DOS is difficult to customize.</b> There are fe external &ldquo;hooks&rdquo; provided to allow system programmers the opportunity to personalize the operating system to special applications. For example, a new command cannot be added to DOS without version dependent patches.
</li>
<li>
DOS file structures and system calls are <b>incompatible</b> with other operating systems. Each operating system Apple has announced in the past has had its on way of organizing data on a diskette. There is no compatibility between DOS, SOS and the Apple Pascal system. This means that special utilities must be written to move data between these systems and that applications developed in one environment will not run without major modifications under any other system.
</li>
<li>
DOS does not provide a consistent mechanism for supporting multiple peripherals which can generate hardware <b>interrupts</b>. In the past, various manufacturers have implemented interrupt handlers on their on, often resulting in incompatibilities between their devices.
</li>
<li>
DOS provides little standardization of <b>memory use</b> and of operating system interfaces. Most &ldquo;interesting&rdquo; locations within DOS are internalized and therefore not officially available to the programmer. Also, since there is no standard way to set aside portions of memory for specific applications, it is difficult to put a program in a &ldquo;safe&rdquo; place so that it may co-reside with another application.
</li>
<li>
Although DOS allows most of its commands to be executed from within a BASIC program, additional function is needed. Under DOS there is no way to conveniently read a file directory from a BASIC program, or to save and restore Applesoft’s variables, for example. Likewise, the implementation of program CHAINing is not integrated into DOS.
</li>
<li>
Additional functions under DOS which would be desirable (to name only a few) are: a display of the amount of freespace left on a diskette; a way to show the address and length parameters stored with a binary file; and a way to create unbootable data disks to increase storage space for user files.
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-2.2">2.2</a> Enter ProDOS
</h2>
<div class="Unindented">
In January 1984, Apple introduced a new disk operating system for its Apple II family of computers. ProDOS is intended to replace DOS 3.3 as the standard Apple II operating system, and it is now being shipped with all new Disk II drives instead of DOS. Although, on the surface, ProDOS is very similar in appearance to DOS 3.3, it represents a major redesign and is a new an separate system. From the beginning, ProDOS addresses all of DOS’s weaknesses mentioned above:
</div>
<ul>
<li>
ProDOS is up to <b>eight times faster</b> than DOS in disk access. A new &ldquo;direct read&rdquo; mode has been implemented which allows multisector reads to be performed directly from the disk to the programmer’s buffer without multiple buffering within ProDOS itself. When performing direct reads, ProDOS can transfer data from the diskette at a rate of eight kilobytes per second (at best, DOS can read one kilobyte per second). Even when reading small amounts of data from the disk, ProDOS does less multiple buffering than does DOS.
</li>
<li>
ProDOS provides a <b>device independent</b> interface to &ldquo;foreign&rdquo; mass storage devices. The concept of a hierarchically organized disk &ldquo;volume&rdquo; was created to allow for large capacity devices, and vectors are provided to allow device drivers for non-standard disks to be integrated into ProDOS. Directories may be dynamically expanded to unlimited size to allow for large numbers of files, and an individual file may now occupy up to 16 million bytes of space on a volume. The largest volume which can be supported is 32 million bytes.
</li>
<li>
Device <b>driver support</b> has also been provided for calender/clock peripherals, allowing time and date stamping of files, and support for the Apple IIe and IIc 80-column hardware is a part of ProDOS.
</li>
<li>
Learning from its mistakes with DOS, Apple has externalized as many ProDOS functions as possible through well defined <b>system calls</b>. In addition to standard file management system calls, interfaces are provided to support user written commands to the BASIC interpreter, and to invoke a ProDOS command from within an assembly language program.
</li>
<li>
The ProDOS file and volume structure is nearly identical to that of the Apple III <b>SOS</b> operating system. There are even strong similarities between ProDOS system calls and those on Apple’s Macintosh! A ProDOS volume may be accessed from SOS directly without the need for a special utility program. ProDOS system calls are a large subset of those offered under SOS and applications may be developed which will easily port between the two operating systems.
</li>
<li>
ProDOS defines a protocol which <b>interrupting</b> devices may use to coexist harmoniously in the same machine. Up to four interrupt drivers may be installed in ProDOS, and each device need not know that the others exist.
</li>
<li>
Most locations of general interest have been placed in externally accessible areas of memory called <b>global pages</b>. Though a global page, a user written program can obtain the current ProDOS version number, the most recent values entered on a ProDOS command line, or the configuration of the current hardware including the machine type, memory size, and the contents of the peripheral card slots. In addition, a voluntary system has been provided to &ldquo;fence off&rdquo; portions of memory for special uses by marking a memory bit map in the system global page.
</li>
<li>
New support has been provided under ProDOS for <b>BASIC</b> programmers. A BASIC program can now read a directory file, make a &ldquo;snapshot&rdquo; of its variables on disk and later restore them, and chain between programs, preserving variables.
</li>
<li>
The <b>CATALOG</b> command under ProDOS displays the address and length values of binary files as well as the space remaining on a disk volume.
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-2.3">2.3</a> More ProDOS Advantages
</h2>
<div class="Unindented">
In addition to addressing needs which grew out of DOS, Apple has also come up with <b>other enhancements</b> with ProDOS:
</div>
<ul>
<li>
A new &ldquo;smart&rdquo; RUN command (&ldquo;–&rdquo;) has been added which will automatically perform the function of a RUN, EXEC, or BRUN as appropriate depending upon the type of file being RUN.
</li>
<li>
The assembly language interface has been expanded to include obtaining and updating statistical information about a file, moving the end of file mark in a file, allowing line at a time reads versus byte stream reads, determining the names of diskettes mounted in online drives, and creating new files or directories. In addition, entry points are included to allow applications to pass control from program to program and to allocate memory.
</li>
<li>
The language independent, file management portion of ProDOS (the Kernel) is a separate unit from the BASIC support routines. Applications may be written which reclaim the memory normally occupied by BASIC support routines.
</li>
<li>
All ProDOS utilities are menu oriented with enhanced user interfaces.
</li>
<li>
Applesoft string &ldquo;garbage collection&rdquo; has been rewritten under ProDOS, and is now many times faster and more efficient.
</li>
<li>
Files may be restricted or &ldquo;locked&rdquo; by type of access. Read only files may be established, or files which may be written but not destroyed, for example.
</li>
<li>
The binary save (BSAVE) command has been enhanced under ProDOS. BSAVEs into existing binary files whose A and/or L keywords are omitted will use the current values of the target file. Also, other file types besides BIN files may be BLOADed and BSAVEd, allowing direct modification at a byte-by-byte level. (For example, one can BLOAD a text file and examine it in memory, making modifications to the hex image.)
</li>
<li>
The record length of a random access text file is now stored with the file, allowing subsequent BASIC programs to access it without knowing its record length.
</li>
<li>
Data disk volumes may now be created which do not contain an image of the operating system. ProDOS makes more efficient use of the disk, resulting in slightly more user storage for files.
</li>
<li>
More information about a file is stored in the directory entry under ProDOS than under DOS. The length of a binary or Applesoft file, for example, is stored in the directory, not in the file itself.
</li>
<li>
The manner in which the ProDOS BASIC Interpreter intercepts a BASIC program’s command lines has been improved and is more reliable. It is now very difficult to &ldquo;disconnect&rdquo; ProDOS as could occur under DOS.
</li>
<li>
More file types (256) are available under ProDOS. Some are &ldquo;user definable.&rdquo;
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-2.4">2.4</a> What You Give Up With ProDOS
</h2>
<div class="Unindented">
ProDOS is not for everyone, however. There are a number of <b>disadvantages</b> to moving from DOS to ProDOS:
</div>
<ul>
<li>
Most assembly language programs which ran under DOS will have to be rewritten for ProDOS. The file management interfaces are completely different, and the &ldquo;PRINT control-D&rdquo; mechanism which worked from assembly language under DOS no longer works under ProDOS. This means that most commercial applications, such as word processors, compilers, and spreadsheets, will not be available for ProDOS until they are converted. This state of affairs will change, however, since ProDOS is now the &ldquo;official&rdquo; operating system for Apple II computers.
</li>
<li>
Apple’s older version of BASIC, Integer BASIC, is not supported under ProDOS. Indeed, Applesoft must be in the motherboard ROMs for the ProDOS BASIC Interpreter to work at all. This means that only the ProDOS Kernel, used in a standalone, run-time environment, will run on an original, Integer Apple II. It is likely that someone (probably not Apple) will soon market an Integer BASIC interpreter for ProDOS, however.
</li>
<li>
ProDOS requires 64K to support BASIC programming and commands. It can be made to run in 48K for run-time assembly language applications, but 64K is required to run the BASIC Interpreter which incorporates all of the ProDOS commands (e.g. CATALOG, BLOAD, etc.).
</li>
<li>
Under BASIC, less memory is available to the program. Under DOS, HIMEM was set at $9600 with three file buffers built into DOS. Under ProDOS, HIMEM is at $9600 with no file buffers built in. Thus, as soon as a ProDOS BASIC program opens a file, HIMEM is moved down and 1K less memory is available. Likewise. since the Kernel occupies the Language Card (or bank switched memory), this space may not be used for other purposes. (DOS could be relocated into the language card to make more space available to BASIC programs. Also, Applesoft enhancement aid programs typically were loaded into the language card’s alternate 4K bank under DOS. This is where ProDOS stores its Quit code now).
</li>
<li>
ProDOS only maintains a single directory prefix for all volumes, rather than remembering a default prefix for each volume. Hence, diskette swapping and access to multiple volumes at once can be cumbersome.
</li>
<li>
Although the pathname for a file may be 64 characters, the actual name of a file may be only 15 characters, and may not include any special characters or blanks (other than &ldquo;period&rdquo;). 30 characters were permitted under DOS.
</li>
<li>
Under DOS, up to 16 files may be opened concurrently by a BASIC program. Under ProDOS, only eight files may be opened at once. Also, an open file &ldquo;cost&rdquo; 595 bytes under DOS; under ProDOS, a 1024-byte buffer is allocated.
</li>
<li>
BASIC programs which are computationally oriented will run bout four percent slower on ProDOS than they did under DOS. This is because the ProDOS BASIC Interpreter leaves Applesoft TRACE running (invisibly) at all times so that it can monitor the execution of the program and perform garbage collection and disk commands. On the other hand, if strings or disk accesses are used, this degradation of performance will be more than offset by improvements in these areas.
</li>
<li>
Several DOS commands have been removed, including NOMON, MON, and VERIFY. There is no way to see the commands in an EXEC file as they are executed.
</li>
<li>
If a ProDOS directory is destroyed, it is harder to reconstruct than was the DOS CATALOG track. More information is stored in the directory making it harder to identify a file’s type by examining its data blocks. Also, since seedling files do not have index blocks (similar to DOS Track/Sector Lists), they are almost impossible to find once their directory entries are gone.
</li>

</ul>
<h2 class="Section">
<a class="toc" name="toc-Section-2.5">2.5</a> Other Differences Between ProDOS and DOS
</h2>
<div class="Unindented">
There are a few other minor differences between ProDOS and DOS which are worth noting:
</div>
<ul>
<li>
The BRUN command now calls the target program rather than humping to it as did DOS. The invoked program may return to ProDOS via a return subroutine.
</li>
<li>
CLOSE will not produce an error message if the file named is not currently open.
</li>
<li>
APPEND implies WRITE. It is not necessary to follow an APPEND command with a WRITE command in a BASIC program.
</li>
<li>
ASCII text in ProDOS directory entries or TXT files is stored with the most significant bit <b>off</b>.
</li>

</ul>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-3">3</a> Disk II Hardware And Diskette Formatting
</h1>
<div class="Unindented">
This chapter will explain how data is stored on a floppy diskette using a disk drive (Disk II family or equivalent). Much of the information in this chapter is applicable not only to ProDOS, but also to other operating systems on the Apple computer (DOS, PASCAL, CP/M). Because ProDOS isolates device specific code, the contents of this chapter should not be considered a prerequisite for understanding succeeding chapters.
</div>
<div class="Indented">
For system housekeeping, ProDOS divides external storage devices into blocks. Each <b>block</b> contains 512 bytes of information. It is device independent in that each device has its own driver. This driver enables ProDOS to read and write blocks, and additionally to obtain the status of a device. The device itself may actually store information in a number of ways and not necessarily in blocks. Blocks can be thought of as a conceptual unit of data that was created in software, having little or no relation to how data is actually stored on an external storage device. In fact, the standard Disk II stores information in a track and sector format. The device driver provides a mapping between these tracks and sectors, and the blocks. Since a sector contains 256 bytes, two <b>sectors</b> are required for each block. There are 560 sectors on a diskette and therefore 280 blocks. Chapter 4 deals with how ProDOS allocates these blocks to create files.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.1">3.1</a> Tracks And Sectors
</h2>
<div class="Unindented">
As stated above, a diskette is divided into tracks and sectors. This is done during the initialization or formatting process. A track is a physically defined circular path which is concentric with the hole in the center of the diskette. Each track is identified by its distance from the center of the disk. Similar to a phonograph stylus, the read/write head of the disk drive may be positioned over any given track. The tracks are similar to the grooves in a record, but they are not connected in a spiral. Much like playing a record, the diskette is spun at a constant speed while the data is read from or written to its surface with the read/write head. Apple formats its diskettes into 35 tracks, numbered from 0 to 34, track 0 being the outermost track and track 34 the innermost. Figure 3.1 illustrates the concept of tracks, although they are invisible to the eye on a real diskette.
</div>
<div class="Indented">
It should be pointed out, for the sake of accuracy, that the disk arm can position itself over 70 distinct locations or <b>phases</b>. To move the arm from one track to the next, two phases of the stepper motor which moves the arm must be cycled. This implies that data might be stored on 70 tracks, rather than 35. Unfortunately, the resolution of the read/write head is such that attempts to use these phantom <b>half</b> tracks create so much cross-talk that data is lost or overwritten. Although standard ProDOS uses only full tracks (even phases), some copy protected disks use half tracks (odd phases) or combinations of the two. This will work provided that no data is closer than two phases from other data. See APPENDIX B for more information on copy protection schemes.
</div>
<div class="Indented">
A <b>sector</b> is a subdivision of a track. It is the smallest unit of &ldquo;updatable&rdquo; data on the diskette. While ProDOS reads or writes data a block at a time (two sectors), the device driver operates on one sector at a time. This allows the device driver to use only a small portion of memory as a buffer during read or write operations. Apple has used two different track formats to date. The initial operating system divided the track into 13 sectors m but all recent operating systems use 16 sectors. The sectoring does not use the index hole, provided on most diskettes, to locate the first sector of the track. The implication is that the software must be able to locate any given track and sector with no help from the hardware. This scheme, known as <b>soft sectoring</b>, takes a little more space for storage but allows flexibility, as evidenced by the previous change from 13 sectors to 16 sectors per track. The following table categorizes the amount of data stored on a diskette under ProDOS. Both system and data diskettes are categorized.
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" colspan="2">
Diskette Organization
</td>

</tr>
<tr>
<td align="left" valign="top">
Tracks
</td>
<td align="right" valign="top">
35
</td>

</tr>
<tr>
<td align="left" valign="top">
Sectors Per Track
</td>
<td align="right" valign="top">
16
</td>

</tr>
<tr>
<td align="left" valign="top">
Sectors Per Diskette
</td>
<td align="right" valign="top">
560
</td>

</tr>
<tr>
<td align="left" valign="top">
Bytes Per Sector
</td>
<td align="right" valign="top">
256
</td>

</tr>
<tr>
<td align="left" valign="top">
Bytes Per Diskette
</td>
<td align="right" valign="top">
143,360
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
Usable Blocks For Data Storage
</td>

</tr>
<tr>
<td align="left" valign="top">
  ProDOS System Diskette
</td>
<td align="right" valign="top">
221
</td>

</tr>
<tr>
<td align="left" valign="top">
  ProDOS Data Diskette
</td>
<td align="right" valign="top">
273
</td>

</tr>
<tr>
<td align="left" valign="top">
Usable Bytes Per Diskette
</td>
<td align="right" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
  ProDOS System Diskette
</td>
<td align="right" valign="top">
113,152
</td>

</tr>
<tr>
<td align="left" valign="top">
  ProDOS Data Diskette
</td>
<td align="right" valign="top">
139,776
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.2">3.2</a> Track Formatting
</h2>
<div class="Unindented">
Up to this point we have have broken down the structure of data to the track and sector level. To better understand how data is stored and retrieved, we will start at the bottom and work up.
</div>
<div class="Indented">
As this manual is about software (ProDOS), we will deal primarily with the function of hardware rather than explain how it performs that function. For example, while data is in fact stored as a continuous stream of analog signals, we will deal with discrete <b>digital</b> data, i.e. a &ldquo;0&rdquo; or a &ldquo;1&rdquo;. We recognize that the hardware converts analog data to digital data, but how this is accomplished is beyond the scope of this manual. For a full and detailed explanation of the hardware, please rever to Jim Sather’s excellent book, <i>Understanding the Apple II</i>, published by Quality Software.
</div>
<div class="Indented">
Data bits are recorded on the diskette in precise intervals. The hardware recognizes each of these intervals as either a &ldquo;0&rdquo; or a &ldquo;1&rdquo;. We will define these intervals to be <b>bit cells</b>. A bit cell can be thought of as the distance the diskette moves in four machine cycles, which is about four microseconds. Using this representation, data written on and read back from the diskette takes the form shown in Figure 3.2. The data pattern shown represents a binary value of 101.
</div>
<div class="Indented">
A byte as recorded on the disk consists of eight (8) consecutive bit cells. The <b>most significant bit</b> cell is usually referred to as bit cell 7, and the <b>least significant</b> is <b>bit</b> cell 0. When reference is made to a specific data bit (i.e. data bit 5), it is with respect to the corresponding bit cell (bit cell 5). <b>Data</b> is written and read serially, one bit at a time. Thus, during a write operation, bit cell 7 of each byte is written first, and bit cell 0 is written last. Correspondingly, when data is being read back from the diskette, bit cell 7 is read first and bit cell 0 is read last. Figure 3.3 illustrates the relationship of the bits within a byte.
</div>
<div class="Indented">
To graphically show how bits are stored and retrieved, we must take certain liberties. The diagrams are a representation of what functionally occurs within the disk drive. For the purposes of our presentation, the hardware interface to the diskette will be represented as an 8-bit <b>data register</b>. Since the hardware involved considerably more complication, from a software standpoint, it is reasonable to use the data register, as it accurately embodies the function of data flow to and from the diskette. For a further discussion of the hardware, please see APPENDIX D.
</div>
<div class="Indented">
Figure 3.4 shows the three bits, 101, being read from the diskette data stream into the data register. Of course, another five bits would be read to fill the register.
</div>
<div class="Indented">
Writing data can be depicted much in the same way (See Figure 3.5). It should be noted that, while in write mode, zeroes are being brought into the data register to replace the data being written. It is the task of the software to make sure that the register is loaded and instructed to write on 32-cycle (microsecond) intervals. If not, zero bits will continue to be written every four cycles, which is in fact exactly how self-sync bytes are created. Self sync bytes will be covered in detail shortly.
</div>
<div class="Indented">
A <b>field</b> is made up of a group of consecutive bytes. The number of bytes varies, depending upon the nature of the field. The two types of fields present on a diskette are the <b>Address Field</b> and the <b>Data Field</b>. They are similar in that they both contain a prologue, a data area, a checksum, and an epilogue. Each field on track is separated from adjacent fields by a number of bytes. These areas of separation are called <b>gaps</b> and are provided for two reasons. First, they allow the updating of one field without affecting adjacent fields (an the Apple, only data fields are updated). Secondly, they allow the computer time to decode the address field before the corresponding data field can pass beneath the read/write head.
</div>
<div class="Indented">
All gaps are primarily alike in content, consisting of self-sync hexadecimal FF’s and vary only in the number of bytes they contain. Figure 3.6 is a diagram of a portion of a typical track, broken into its major components.
</div>
<div class="Indented">
Self sync or auto-sync bytes are special bytes that make up the three different types of gaps on a track. They are so named because of their ability to automatically bring the hardware into synchronization with data bytes on the disk. The difficulty in doing this lies in the fact that the hardware reads bits, and the data must be stored as 8-bit bytes. It has been mentioned that a track is literally a continuous stream of data bits. In fact, at the but level, there is no way to determine where a byte starts or ends, because each bit cell is exactly the same, written in precise intervals with its neighbors. When the drive is instructed to read data, it will start wherever it happens to be on a particular track. That could be anywhere among the 50,000 or so bits on a track. The hardware finds the first bit cell with data in it and proceeds to read the following seven bits of data into the 8-bit register. In effect, it assumes that it has started at the beginning of a data byte. Of course, in reality, it could have started at any of the &ldquo;1&rdquo; bits of the byte. Pictured in Figure 3.7 is a small portion of a track.
</div>
<div class="Indented">
From looking at the data, there is no way to tell what bytes are represented, because we don’t know where to start. This is exactly the problem that self-sync bytes overcome.
</div>
<div class="Indented">
A <b>self-sync</b> byte is defined to be a hexadecimal FF with a special difference. It is, in fact,a 10-bit byte rather than an 8-bit byte. Its two extra bits are zeroes. Figure 3.8 shows the difference between a normal data hex FF that might be found elsewhere on the disk and a self-sync hex FF byte.
</div>
<div class="Indented">
A self-sync byte is generated by using a 40-cycle (microsecond) loop while writing an FF. A bit is written every four cycles, so two of the zero bits brought into the data register while the FF was being written are also written to the disk, making the 10-bit byte. It can be shown, using Figure 3.9, that four self-sync bytes are sufficient to guarantee that the hardware is reading valid data. The reason for this is that the hardware requires the first bit of a byte to be a &ldquo;1&rdquo;. Pictured at the top of the figure is a stream of four self-sync bytes followed by a normal FF. Each row below that demonstrates what the hardware will read should it start reading at any given bit in the first byte. In each case, by the time the four sync bytes have passed beneath the read/write head, the hardware will be <b>synced</b> to read the data bytes that follow. As long as the disk is left in read mode, it will continue to correctly interpret the data unless there is an error on the track.
</div>
<div class="Indented">
We can now discuss the particular portions of a track in detail. The three gaps will be covered first. Unlike some other disk formats, the size of the three gap types will vary from drive to drive and even from track to track. During the formatting process, ProDOS will start with large gaps and keep making them smaller until an entire track can be written without overlapping itself. A minimum number of self-sync bytes is maintained for each gap type. The result is fairly uniform gap sizes within each particular track. 
</div>
<div class="Indented">
<b>Gap 1</b> is the first data written to a track during initialization. Its purpose is twofold. The gap originally consists of 128 self-sync bytes, a large enough area to insure that all portions of a track will contain data. Since the speed of a particular drive may vary, the total length of the track in bytes is uncertain, and the percentage occupied by data is unknown. The initialization process is set up, however, so that even on drives of differing speeds, the last data field written will overlap Gap 1, providing continuity over the entire physical track. Unlike earlier operating systems, ProDOS will let you know if your drive is too fast or too slow. The remaining portion of Gap 1 must be approximately 75% as long as a Gap 3 on that track, enabling it to serve as a Gap 3 type for Address Field number 0 (See Figure 3.6 for clarity).
</div>
<div class="Indented">
<b>Gap 2</b> appears after each Address Field and before each Data Field. Its primary purpose is to provide time for the information in an Address Field to be decoded by the computer before a read or write takes place. If the gap was too short, the beginning of the Data Field might spin past while ProDOS was still determining if this was the sector to be read. The 200 cycles that five self-sync bytes provide seems ample time to decode an Address Field. When a Data Field is written, there is no guarantee that the write will occur in exactly the same spot each time. This is due to the fact that the drive which is rewriting the Data Field may not be the one which originally formatted or wrote it. Since the speed of the drives can vary, it is possible that the write could start in mid-byte (see Figure 3.10). For this reason, the length of Gap 2 varies from five to ten bytes. This is not a problem as long as the difference in positioning is not too great. To insure the integrity of Gap 2 when writing a data field, five self-sync bytes are written prior to writing the Data Field itself. This serves two purposes. Since relatively little time is spent decoding an address field, the five bytes help place the Data Field near its original position. Secondly, and more importantly, the five self-sync bytes are the minimum number required to guarantee read-synchronization. It is probable that, in writing a Data Field, at least one sync byte will be destroyed. This is because, just as in reading bits on the track, the write may not begin on a byte boundary, thus altering an existing byte. Figure 3.11 illustrates this.
</div>
<div class="Indented">
<b>Gap 3</b> appears after each Data Field and before each Address Field. It is longer than Gap 2 and care is taken to make sure it ranges from 16 to 28 bytes in length. It is quite similar in purpose to Gap 2. Gap 3 allows the additional time needed to manipulate the data that has been read before the next sector is to be read. The length of Gap 3 is not as critical as that of Gap 2. If the following Address Field is missed, ProDOS can always wait for the next time it spins around under the read/write head (one revolution of the disk at most). Since Address Fields are never rewritten, there is no problem with Gap 3 providing synchronization, since only the first part of the gap can be overwritten or damaged (see Figure 3.10 for clarity).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.1">3.2.1</a> Address Fields
</h3>
<div class="Unindented">
An examination of the contents of the two types of field is in order. The Address Field contains the <b>address</b> or identifying information about the Data Field which follows it. The volume, track, and sector number of any given sector can be thought of as it &ldquo;address,&rdquo; much like a country, city, and street number might identify a house. As shown previously in Figure 3.6, there are a number of components which make up the Address Field. A more detailed illustration is given in Figure 3.12.
</div>
<div class="Indented">
Each byte of the Address Field is encoded into two bytes when written to the disk. Appendix C describes the &ldquo;4 and 4&rdquo; method used for Address Field encoding.
</div>
<div class="Indented">
The <b>prologue</b> consists of three bytes which form a unique sequence, found in no other component of the track. This fact enables ProDOS to locate an Address Field with almost no possibility of error. The three bytes are $D5, $AA, and $96. The $D5 and $AA are reserved (never written as data), thus insuring the uniqueness of the prologue. The $96, following this unique string, indicates that the data following constitutes an Address Field (as opposed to a Data Field). The address information follows next, consisting of the <b>volume<span class="FootOuter"><span class="SupFootMarker"> [A] </span><span class="HoverFoot"><span class="SupFootMarker"> [A] </span>Volume number is a leftover from earlier operating systems and is not used by ProDOS.</span></span></b>, <b>track</b>, and <b>sector</b> number and a checksum. This information is absolutely essential for ProDOS to know where it is positioned on a particular diskette. The <b>checksum</b> is computed by exclusive-ORing the first three pieces of information, and is used to verify its integrity. Lastly follows the <b>epilogue</b>, which contains the three bytes $DE, $AA, and $EB. The $EB is only partly written during initialization, and is therefore never verified when an Address Field is read. The epilogue bytes are sometimes referred to as <b>bit-slip marks</b>, which provide added assurance that the drive is still in sync with the bytes on the disk. These bytes are probably unnecessary, but do provide a means of double checking.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.2.2">3.2.2</a> Data Fields
</h3>
<div class="Unindented">
The other field type is the Data Field. Much like the Address Field, it consists of a <b>prologue</b>, <b>data</b>, <b>checksum</b>, and an <b>epilogue</b> (refer to Figure 3.13). The Prologue differs only in the third byte. The bytes are $D5, $AA, and $AD, which again form a unique sequence, enabling ProDOS to locate the beginning of the sector data. The data consists of 342 bytes of encoded data. (The encoding scheme used is quite complex and is documented in detail in Appendix C.) The data is followed by a checksum byte, used to verify the integrity of the data just read. The epilogue portion of the Data Field is absolutely identical to the epilogue in the Address Field and serves the same function.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-3.3">3.3</a> Disk II Block and Sector Interleaving
</h2>
<div class="Unindented">
Because the Disk II is such an integral part of the Apple II family of machines, it is important that it perform efficiently. Once major factor in disk drive performance is how the data is arranged on the diskette. Because the diskette spins and the head that reads and writes the data is stationary, it is necessary to wait for a particular portion of a given track to pass by. This waiting (rotational delay) can add significant time to a disk access if the data is poorly arranged. <b>Interleaving</b> (or skewing) is the arranging of data at the block or sector level to maximize access speed. It effectively places a gap between blocks or sectors that will normally be accessed sequentially, allowing sufficient time for internal housekeeping before the next one appears. In general, if blocks or sectors are poorly arranged on a track, it is usually necessary to wait an entire revolution of the diskette before the next desired block or sector can be accessed.
</div>
<div class="Indented">
The first versions of Apple’s operating system used <b>physical interleaving</b> on the disk. (That is, sectors were written in a particular order on the diskette.) A number of different schemes were used in an attempt to maximize performance. This worked reasonably well, but because different methods were used for different operations, performance suffered. Later versions standardized the physical interleaving (as sequential), and used a software method to try to maximize performance. An attempt was also made to standardize some operations, but performance still was not optimal as evidenced by a proliferation of &ldquo;fast&rdquo; DOS’s.
</div>
<div class="Indented">
ProDOS provides an impressive improvement over Apple’s earlier operating systems. Several factors account for the dramatic improvement. The routine to read data is significantly faster, minimizing the delay occurring between read operations. The data is dealt with in larger pieces (512 vs. 256 bytes), lowering the number of requests to the code that actually reads and writes data (Device Driver). And almost all operations involve files stored on sequential blocks. As a disk begins to get full, this will not always be possible and some file will be discontinuous; but for the most part, all operations (loading ProDOS or Applesoft BASIC, reading or writing to files or a directory) involve data in contiguous pieces. This greatly simplifies the problem of finding an optimal interleaving for disk accesses.
</div>
<div class="Indented">
In ProDOS, the interleaving is done in software. The 16 sectors are in numerically ascending order on the diskette (0, 1, 2, \SpecialChar ldots 15), and are not physically interleaved at all. An algorithm is used to translate block numbers into physical sector numbers used by the ProDOS device driver. For example, if the block number requested were 2, this would be translated to track 0, physical sectors 8 and A<span class="FootOuter"><span class="SupFootMarker"> [B] </span><span class="HoverFoot"><span class="SupFootMarker"> [B] </span>Those familiar with DOS 3.3 should note that physical sector numbers and DOS 3.3 sector numbers are not the same. Most &ldquo;disk utilities&rdquo; use DOS 3.3 sector numbers and not physical sector numbers. The bottom of Table 3.1 shows how DOS 3.3 sector numbers are related to ProDOS block numbers.</span></span>. Figure 3.14 illustrates the concept of <b>software interleaving</b> and Table <a class="Reference" href="#tab:ProDOS-Block-Conversion">3.1↓</a> shows the mapping of physical sectors to blocks for a Disk II or compatible drive.
</div>
<div class="Indented">
There are two kinds of interleaving to consider in the case of ProDOS. First, there is the interleaving of the two sectors that make up a block. This will be referred to as <b>intra-block</b> or &ldquo;within block&rdquo; interleaving. Second, there is the interleaving between blocks on a given track. This will be referred to as <b>inter-block</b> or &ldquo;between block&rdquo; interleaving. It should be noted that we are concerned primarily with delays within ProDOS and the Disk II Device Driver, and not with delays that may be present in various application packages.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="tab:ProDOS-Block-Conversion"> </a><div class="table">
<div class="caption">
Table 3.1 ProDOS Block Conversion Table for Diskettes
</div>
<table>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="center" valign="top" colspan="8">
PHYSICAL SECTOR
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="center" valign="top">
0 &amp; 2
</td>
<td align="center" valign="top">
4 &amp; 6
</td>
<td align="center" valign="top">
8 &amp; A
</td>
<td align="center" valign="top">
C &amp; E
</td>
<td align="center" valign="top">
1 &amp; 3
</td>
<td align="center" valign="top">
5 &amp; 7
</td>
<td align="center" valign="top">
9 &amp; B
</td>
<td align="center" valign="top">
D &amp; F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 0
</td>
<td align="center" valign="top">
000
</td>
<td align="center" valign="top">
001
</td>
<td align="center" valign="top">
002
</td>
<td align="center" valign="top">
003
</td>
<td align="center" valign="top">
004
</td>
<td align="center" valign="top">
005
</td>
<td align="center" valign="top">
006
</td>
<td align="center" valign="top">
007
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1
</td>
<td align="center" valign="top">
008
</td>
<td align="center" valign="top">
009
</td>
<td align="center" valign="top">
00A
</td>
<td align="center" valign="top">
00B
</td>
<td align="center" valign="top">
00C
</td>
<td align="center" valign="top">
00D
</td>
<td align="center" valign="top">
00E
</td>
<td align="center" valign="top">
00F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 2
</td>
<td align="center" valign="top">
010
</td>
<td align="center" valign="top">
011
</td>
<td align="center" valign="top">
012
</td>
<td align="center" valign="top">
013
</td>
<td align="center" valign="top">
014
</td>
<td align="center" valign="top">
015
</td>
<td align="center" valign="top">
016
</td>
<td align="center" valign="top">
017
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 3
</td>
<td align="center" valign="top">
018
</td>
<td align="center" valign="top">
019
</td>
<td align="center" valign="top">
01A
</td>
<td align="center" valign="top">
01B
</td>
<td align="center" valign="top">
01C
</td>
<td align="center" valign="top">
01D
</td>
<td align="center" valign="top">
01E
</td>
<td align="center" valign="top">
01F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 4
</td>
<td align="center" valign="top">
020
</td>
<td align="center" valign="top">
021
</td>
<td align="center" valign="top">
022
</td>
<td align="center" valign="top">
023
</td>
<td align="center" valign="top">
024
</td>
<td align="center" valign="top">
025
</td>
<td align="center" valign="top">
026
</td>
<td align="center" valign="top">
027
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 5
</td>
<td align="center" valign="top">
028
</td>
<td align="center" valign="top">
029
</td>
<td align="center" valign="top">
02A
</td>
<td align="center" valign="top">
02B
</td>
<td align="center" valign="top">
02C
</td>
<td align="center" valign="top">
02D
</td>
<td align="center" valign="top">
02E
</td>
<td align="center" valign="top">
02F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 6
</td>
<td align="center" valign="top">
030
</td>
<td align="center" valign="top">
031
</td>
<td align="center" valign="top">
032
</td>
<td align="center" valign="top">
033
</td>
<td align="center" valign="top">
034
</td>
<td align="center" valign="top">
035
</td>
<td align="center" valign="top">
036
</td>
<td align="center" valign="top">
037
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 7
</td>
<td align="center" valign="top">
038
</td>
<td align="center" valign="top">
039
</td>
<td align="center" valign="top">
03A
</td>
<td align="center" valign="top">
03B
</td>
<td align="center" valign="top">
03C
</td>
<td align="center" valign="top">
03D
</td>
<td align="center" valign="top">
03E
</td>
<td align="center" valign="top">
03F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 8
</td>
<td align="center" valign="top">
040
</td>
<td align="center" valign="top">
041
</td>
<td align="center" valign="top">
042
</td>
<td align="center" valign="top">
043
</td>
<td align="center" valign="top">
044
</td>
<td align="center" valign="top">
045
</td>
<td align="center" valign="top">
046
</td>
<td align="center" valign="top">
047
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 9
</td>
<td align="center" valign="top">
048
</td>
<td align="center" valign="top">
049
</td>
<td align="center" valign="top">
04A
</td>
<td align="center" valign="top">
04B
</td>
<td align="center" valign="top">
04C
</td>
<td align="center" valign="top">
04D
</td>
<td align="center" valign="top">
04E
</td>
<td align="center" valign="top">
04F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK A
</td>
<td align="center" valign="top">
050
</td>
<td align="center" valign="top">
051
</td>
<td align="center" valign="top">
052
</td>
<td align="center" valign="top">
053
</td>
<td align="center" valign="top">
054
</td>
<td align="center" valign="top">
055
</td>
<td align="center" valign="top">
056
</td>
<td align="center" valign="top">
057
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK B
</td>
<td align="center" valign="top">
058
</td>
<td align="center" valign="top">
059
</td>
<td align="center" valign="top">
05A
</td>
<td align="center" valign="top">
05B
</td>
<td align="center" valign="top">
05C
</td>
<td align="center" valign="top">
05D
</td>
<td align="center" valign="top">
05E
</td>
<td align="center" valign="top">
05F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK C
</td>
<td align="center" valign="top">
060
</td>
<td align="center" valign="top">
061
</td>
<td align="center" valign="top">
062
</td>
<td align="center" valign="top">
063
</td>
<td align="center" valign="top">
064
</td>
<td align="center" valign="top">
065
</td>
<td align="center" valign="top">
066
</td>
<td align="center" valign="top">
067
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK D
</td>
<td align="center" valign="top">
068
</td>
<td align="center" valign="top">
069
</td>
<td align="center" valign="top">
06A
</td>
<td align="center" valign="top">
06B
</td>
<td align="center" valign="top">
06C
</td>
<td align="center" valign="top">
06D
</td>
<td align="center" valign="top">
06E
</td>
<td align="center" valign="top">
06F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK E
</td>
<td align="center" valign="top">
070
</td>
<td align="center" valign="top">
071
</td>
<td align="center" valign="top">
072
</td>
<td align="center" valign="top">
073
</td>
<td align="center" valign="top">
074
</td>
<td align="center" valign="top">
075
</td>
<td align="center" valign="top">
076
</td>
<td align="center" valign="top">
077
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK F
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 10
</td>
<td align="center" valign="top">
080
</td>
<td align="center" valign="top">
081
</td>
<td align="center" valign="top">
082
</td>
<td align="center" valign="top">
083
</td>
<td align="center" valign="top">
084
</td>
<td align="center" valign="top">
085
</td>
<td align="center" valign="top">
086
</td>
<td align="center" valign="top">
087
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 11
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">2</span>
</td>
<td align="center" valign="top">
090
</td>
<td align="center" valign="top">
091
</td>
<td align="center" valign="top">
092
</td>
<td align="center" valign="top">
093
</td>
<td align="center" valign="top">
094
</td>
<td align="center" valign="top">
095
</td>
<td align="center" valign="top">
096
</td>
<td align="center" valign="top">
097
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">3</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">4</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">5</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">6</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">7</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 18
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">9</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1A
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">B</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">C</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">D</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">E</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK 1<span class="default">F</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK <span class="default">20</span>
</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK <span class="default">21</span>
</td>
<td align="center" valign="top">
108
</td>
<td align="center" valign="top">
109
</td>
<td align="center" valign="top">
10A
</td>
<td align="center" valign="top">
10B
</td>
<td align="center" valign="top">
10C
</td>
<td align="center" valign="top">
10D
</td>
<td align="center" valign="top">
10E
</td>
<td align="center" valign="top">
10F
</td>

</tr>
<tr>
<td align="left" valign="top">
TRACK <span class="default">22</span>
</td>
<td align="center" valign="top">
110
</td>
<td align="center" valign="top">
111
</td>
<td align="center" valign="top">
112
</td>
<td align="center" valign="top">
113
</td>
<td align="center" valign="top">
114
</td>
<td align="center" valign="top">
115
</td>
<td align="center" valign="top">
116
</td>
<td align="center" valign="top">
117
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="center" valign="top">
0 &amp; E
</td>
<td align="center" valign="top">
D &amp; C
</td>
<td align="center" valign="top">
B &amp; A
</td>
<td align="center" valign="top">
9 &amp; 8
</td>
<td align="center" valign="top">
7 &amp; 6
</td>
<td align="center" valign="top">
5 &amp; 4
</td>
<td align="center" valign="top">
3 &amp; 2
</td>
<td align="center" valign="top">
1 &amp; F
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="center" valign="top" colspan="8">
DOS 3.3 SECTOR
</td>

</tr>

</table>

</div>

</div>

</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.1">3.3.1</a> Intra-Block Interleaving
</h3>
<div class="Unindented">
When ProDOS accesses a block, it must of course access the two sectors that make up that block. There is a small delay after the device driver has accessed the first sector, before it can access the second sector. This delay is different for Read and Write operations. The Read operation is so fast that the disk can read two sectors in a row. However, the Write operation takes longer, so for optimal performance there must be a gap between the two sectors that make up a block. If there wasn’t a gap, an entire revolution of the diskette would be required for each block written. A single sector provides a sufficient gap, so intra-block interleaving (within the block) consists of <b>one sector</b>. The result is that ProDOS is able to write to a given block as rapidly as is possible. Some time is lost when reading a block, but no other interleaving scheme would provide the same overall efficiency. Intra-block interleaving is illustrated in Figure 3.15.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.2">3.3.2</a> Inter-Block Interleaving
</h3>
<div class="Unindented">
When ProDOS accesses a number of blocks as required in most disk operations (i.e. reading or writing a directory or a file), another kind of interleaving is involved. There will be a delay between accesses, but it is now between blocks rather than sectors. There is relatively little difference in delay time in the MLI itself between reading and writing — almost all the difference occurs in the device driver. However, when ProDOS writes a block that is already allocated (i.e. part of an existing directory or file), it always reads that block before writing to it. This requires an entire revolution of the diskette regardless of how the interleaving is done. It turns out that, just as for intra-block operations, a <b>single sector</b> is a sufficient gap for reading blocks. Inter-block interleaving is illustrated in Figure 3.16.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.3">3.3.3</a> Reading Or Writing A Block
</h3>
<div class="Unindented">
Assume that we wish to access block 2. ProDOS passes the request to the device driver which in turn converts the block number into its track and sector representation (see Figure 3.14). The arm is moved to the proper track (0) and then a sector is read. This could be any sector, because the diskette is spinning. Sectors are continually read until sector 8 is found. The following two sectors are then read (9 and A) which completes the read of block 2 (sectors 8 and A). Depending on where we start on the track, we could read between 3 and 18 sectors. The same process occurs when writing a single block, with one small difference. After sector 8 is located and written to, the delay required to ready the data for sector A will cause us to miss reading sector 9. This does not alter the amount of rotation necessary to complete the task. To summarize, the time required to either read or write a single block consists of two factors. (We are assuming the track has already been located). First, there is the time required to <b>locate</b> the first sector of the block — this is variable and ranges between 0 and the time of one full rotation of the diskette. Second is the time required to actually <b>read or write</b> the two sectors that make up the block — this is fixed and always requires 3/16 rotation of the diskette.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-3.3.4">3.3.4</a> Reading Or Writing Consecutive Blocks
</h3>
<div class="Unindented">
Let’s examine what occurs when a number of blocks are accessed during reading or writing of a typical file. We will assume the file is reasonably large and takes up a number of blocks. We will confine our observation to a single track in which eight blocks comprise the file of interest. We will assume track 2, which contains blocks 10 through 17 (as in Figure 3.17), and we will further assume that the blocks will be accessed sequentially. When the read/write head moves to track 2, we will start reading sectors until the appropriate sector is found (0 in this case). Then each sector is read until all eight blocks are found. This will require exactly <b>two revolutions</b> of the disk. Writing takes significantly longer because each block is read before being written to. Therefore, once the first sector of the block in question is located, one entire revolution is necessary to write each block. Upon writing a block, ProDOS is able to locate the next block immediately, read it, wait one revolution, and write it. A total of <b>ten revolutions</b> is required to write an entire track as opposed to two revolutions to read it.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-4">4</a> Volumes, Directories, And Files
</h1>
<div class="Unindented">
As was described in Chapter 3, a 16-sector diskette consists of 560 data areas of 256 bytes each, called sectors. These sectors are arranged on the diskette in 35 concentric rings, called tracks, of 16 sectors each. The way ProDOS allocates these tracks of sectors is the subject of this chapter.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.1">4.1</a> The Diskette Volume
</h2>
<div class="Unindented">
ProDOS defines a <b>volume</b> to be any (usually direct access) individual mass storage media. The discussion which follows assumes this media to be a single 35-track diskette, but all of the structures presented here are identical for other diskette sizes and even for a hard disk such as the Apple ProFile. Another interesting point is that the structure of a ProDOS volume is almost identical to that of an Apple III SOS volume. This fact allows greater data compatibility between the two operating systems.
</div>
<div class="Indented">
To make the allocation of sectors more manageable, ProDOS pairs them up to form 512-byte <b>blocks</b>. Since there are 16 sectors per track and 560 sectors per diskette volume, there are eight blocks per track and 280 blocks per volume. These blocks are numbered from 0 to 279 (decimal) or $0000 to $0117 (hexadecimal). The arrangement of blocks on a diskette is shown in Figure 4.1. Of course, on a real diskette, skewing (discussed in Chapter 3) would reorder the blocks on any given track, but, for the purposes of this discussion, the blocks can be assumed to be stored sequentially.
</div>
<div class="Indented">
A file, be it BAS, BIN, TXT, or SYS type, consists of one or more blocks containing data. Since a block is the smallest unit of allocatable space on a ProDOS volume, a file will use up at least one block even if it is less than 512 bytes long; the remainder of the block is wasted. Thus, a file containing 600 characters (or bytes) of data will occupy one entire block and 88 bytes of another with 424 bytes wasted. Knowing that there are 280 blocks on a diskette, one might expect to be able to use up to 280 times 512 or 143,360 bytes of space on a diskette for files. Actually, the largest file that can be stored in 271 blocks long (or 138,752 bytes). The reason for this is that some of the blocks on the diskette volume must be used for what is called overhead.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.1">4.1.1</a> Volume Overhead
</h3>
<div class="Unindented">
Overhead blocks contain the image of the ProDOS bootstrap loader (which is loaded by the ROM on your diskette controller card and, in turn, loads the ProDOS system files into memory), a list of file names and locations of the files on the diskette, and an accounting of the blocks which are free for use by new files or for expansions of existing ones. An example of the way ProDOS uses blocks is given in Figure 4.2.
</div>
<div class="Indented">
Notice that in the case of this diskette volume, system overhead (that part of the diskette which does not actually contain files) falls entirely on track 0 of the diskette (blocks 0 through 7). In fact, there is room for one block’s worth of file data on track 0( block 7). The first block (block 0) is always devoted to the image of the bootstrap loader. (Block 1 is the SOS bootstrap loader.) Following these, and always starting at block 2, is the <b>Volume Directory</b>. The Volume Directory is the &ldquo;anchor&rdquo; of the entire volume. On any diskette (or hard disk for that matter) for any version of ProDOS, the first or &ldquo;key&rdquo; block of the Volume Directory is always in the same place — block 2. Since files can end up anywhere on the diskette, it is through the Volume Directory key block that ProDOS is able to find them. Thus, just as the card catalog is used to locate a book in a library, the Volume Directory is the master index to all of the files on a volume. In addition to describing the name, attributes, and placement of each file, it also contains the block number of the <b>Volume Bit Map</b> which will be described next. The first four bytes of every Volume Directory block are reserved for &ldquo;pointers&rdquo; to (the block numbers of) the previous Volume Directory block and the next Volume Directory block. This structure is called a doubly-linked list and is handy in that, from any block, it is easy to move forward or backward thought the directory entries. The Volume Directory and Volume Bit Map are diagrammed in Figure 4.3.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.1.2">4.1.2</a> Volume Space Allocation — The Volume Bitmap
</h3>
<div class="Unindented">
When a diskette volume is first formatted, only the first seven blocks described above are marked in use. All of the remainder of the diskette blocks are considered &ldquo;free&rdquo; for use with files yet to be created. Each time a new block is required for a file, the free block with the lowest number is used. To keep track of which blocks have been used and which are free, ProDOS maintains one block as the Volume Bit Map. The Volume Bit Map is located by following a pointer in the Volume Directory, however, it is almost always in block 6. It consists of 512 bytes, each byte representing eight blocks on the volume. If the bytes are examined in binary form, each consists of eight bits having a value of one or zero. Thus, if block zero is in use as it always is, then the first byte’s first bit is set to zero. If the ninth block (block 8) is free, then the first bit of the second byte is set to one. Since there are many more bits in the Volume Bit Map (4096 in all) that there could ever be blocks on a diskette, only the first 280 (or 35 bytes) are used. For a 5 megabyte hard disk, like the Apple ProFile, 1241 bytes are needed; in this case, since the number of blocks on the volume is stored in the Volume Directory, ProDOS automatically knows to expect a bigger Volume Bit Map — one which is three blocks long. Bits which do not correspond to a real block (because it would be past the end of the volume) are set to zero. An example of a Volume Bit Map for the volume mapped in Figure 4.2 is given in Figure 4.4. Notice that, since three 1-block files have been allocated, a total of ten blocks are marked &ldquo;in use.&rdquo;
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.2">4.2</a> The Volume Directory
</h2>
<div class="Unindented">
When ProDOS must find a specified file by name, it first reads block 2 of the diskette, the <b>key block</b> of the Volume Directory. If the filename is not found in this block, the next directory block is read, following the pointer in the third and fourth bytes of the current block. Typically, the Volume Directory blocks occupy blocks 2 through 5 of a volume. Of course, as long as a block pointer exists, linking one block to the next, and the first Volume Directory block is block 2, ProDOS does not really care where the rest of the directory blocks are located. Figure 4.5 diagrams the Volume Directory for the example given in Figure 4.2. The figure shows the &ldquo;next block&rdquo; pointer (bytes +2 and +3 in the block) of block 2 in the Volume Directory, as an arrow pointing to block 3. Each block, in turn, has block numbers in the same relative location (+0, +1 and +2, +3) which point backward to the previous block and forward to the next block respectively. If no previous or next block exists, a block number of zero is used to indicate this (block 0, being part of the boot image, would never be a valid block number for a directory or file block, so this is a safe convention). The first block in the Volume Directory (the key block) contains a special entry called the <b>header</b> which describes the directory itself and the characteristics of the volume, etc. This is followed by 12 file descriptive entries. All Volume Directory blocks other than the key block contain descriptions of up to 13 files each. (In practice, these entries can also be used to describe subdirectories, but this will be covered in detail later in the chapter.) Thus, with four Volume Directory blocks, a total of 4 times 13 less 1 (for the Volume Directory Header entry) or 51 files may be described.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.1">4.2.1</a> The Volume Directory Header
</h3>
<div class="Unindented">
The Volume Directory Header is the first entry in the first block of the Volume Directory. As such, its first byte follows the four bytes of next/previous block pointers, so its first byte is at +$04. A description of its format follows<span class="FootOuter"><span class="SupFootMarker"> [C] </span><span class="HoverFoot"><span class="SupFootMarker"> [C] </span>Unless otherwise indicated, all multiple byte numeric values, such as block numbers, EOF marks, etc., are stored least significant byte first, most significant byte last (LO/HI).</span></span>:
</div>
<div class="Indented">
<span class="unknown">\medskip</span><table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="1">
Block Byte
</td>
<td align="justify" valign="top" style="width: 60%;" colspan="1">
Description
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$04
</td>
<td align="justify" valign="top" style="width: 60%;">
STORAGE_TYPE/NAME_LENGTH: The first nibble (top four bits) of this byte describes the type of entry. In this case, this is a Volume Directory Header so this nibble is $F. The low four bits are the length of the name in the next field (the volume name).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$05–$13
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$14–$1B
</td>
<td align="justify" valign="top" style="width: 60%;">
Reserved for future use. Usually zeroes.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$1C–$1F
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$20
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$21
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$22
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$23
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$24
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$25–$26
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$27–$28
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$29–$2A
</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.2.2">4.2.2</a> File Descriptive Entries
</h3>
<div class="Unindented">
Each file (or subdirectory) on a volume has a File Descriptive Entry in the Volume Directory or another directory. These entries all have the same format:
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="1">
Byte Offset
</td>
<td align="justify" valign="top" style="width: 60%;" colspan="1">
Description
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$00
</td>
<td align="justify" valign="top" style="width: 60%;">
<div class="PlainVisible">
STORAGE_TYPE/NAME_LENGTH: The first nibble (top four bits) of this byte describes the type of entry. Currently assigned values are:<br>

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">
$0 – Deleted entry. Available for reuse<br>
$1 – File is a seedling (only one data block)<br>
$2 – File is a sapling (2 to 256 data blocks)<br>
$3 – File is a tree (257 to 32768 data blocks)<br>
$D – File is subdirectory<br>
$E – Reserved for Subdirectory Header entry
</div>
<div class="PlainVisible">
$F – Reserved for Volume Directory Header entry<br>

</div>
<div class="PlainVisible">
The low four bits are the length of the file or subdirectory name in the next field. When a file is deleted, a $00 is stored in this byte.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$01–$0F
</td>
<td align="justify" valign="top" style="width: 60%;">
FILE_NAME: a 15-byte field containing the name of this file. The actual length is defined by NAME_LENGTH above; the remainder of the field is ignored.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$10
</td>
<td align="justify" valign="top" style="width: 60%;">
FILE_TYPE: Primary file type. The hexadecimal value of this byte gives the file type as show in the following table:
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="2">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Type
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Name
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Description
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$00
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Typeless file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$01
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BAD
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
bad block(s) file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$04
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
TXT
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Text file(ASCII text, msb off)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$06
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BIN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Binary file (8-bit<span class="default"> </span>binary image)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0F
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
DIR
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Directory file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$19
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ADB
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
AppleWorks data base file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$1A
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
AWP
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
AppleWorks word processing file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$1B
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ASP
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
AppleWorks spreadsheet file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$EF
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
PAS
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ProDOS PASCAL file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$F0
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CMD
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ProDOS added command file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$F1–$F8
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
User defined file types 1 through 8
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$FC
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BAS
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Applesoft BASIC program file
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$FD
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
VAR
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Applesoft stored variables
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$FE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
REL
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Relocatable object module file (EDASM)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$FF
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
SYS
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ProDOS system file
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$11–$12
</td>
<td align="justify" valign="top" style="width: 60%;">
KEY_POINTER: The block number of the key block of the file. In the case of a seedling file, this is the block number of the index block. For tree files, this is the block number of the master index block. (More on these file structures later.) If the file is a subdirectory, this is the block number of its first block.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$13–$14
</td>
<td align="justify" valign="top" style="width: 60%;">
BLOCKS_USED: The total number of blocks used by this file including index blocks and data blocks. If the file is a subdirectory, this is the number of directory blocks.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$15–$17
</td>
<td align="justify" valign="top" style="width: 60%;">
EOF: The location of the end of the file (EOF) as a 3-byte offset from the first byte. This can also be thought of as the length in bytes of a sequential file.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$18–$1B
</td>
<td align="justify" valign="top" style="width: 60%;">
CREATION: The date and time of the creation of this file. This field is zero if no date was assigned. The format of the field is as follows:
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="2">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BYTE 0 and 1
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
–
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
yyyyyyymmmmddddd
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
year/month/day
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BYTE 2 and 3
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
–
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
000hhhhh00mmmmmm
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
hours/minutes
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">
where each letter above represents one binary bit. This is the standard form for all create and modify date/time stamps in directories.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$1C
</td>
<td align="justify" valign="top" style="width: 60%;">
VERSION: The ProDOS version number under which this file was created. This field tells later versions of ProDOS not to expect to find any fields which were defined by Apple after this version of ProDOS was released. This field indicates the level of upward compatibility between versions. Under ProDOS 1.0, its value is zero.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$1D
</td>
<td align="justify" valign="top" style="width: 60%;">
MIN_VERSION: Minimum version of ProDOS which can access this file. A value in this field implies that significant changes were made to the file structure definition since prior versions of ProDOS were in use, and these older versions would not be able to successfully interpret the file structure of this file. This field indicates the level of downward compatibility between versions. Under ProDOS 1.0, its value is zero.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$1E
</td>
<td align="justify" valign="top" style="width: 60%;">
<div class="PlainVisible">
ACCESS: The bits in this flag byte define how the file may be accessed. The bit assignments are as follows:<br>

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">
$80 – File may be destroyed<br>
$40 – File may be renamed<br>
$20 – File has changed since last backup<br>
$02 – File may be written to
</div>
<div class="PlainVisible">
$01 – File may be read<br>

</div>
<div class="PlainVisible">
All other bits are reserved for future use. An unlocked file’s ACCESS is usually $C3. If a file is locked, ACCESS will be set to $01
</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$1F–$20
</td>
<td align="justify" valign="top" style="width: 60%;">
AUX_TYPE: Auxiliary type field whose contents depend upon FILE_TYPE. Common uses are as follows:
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="2">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Type
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Use
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
TXT
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Random access record length (L from OPEN)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BIN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Load address for binary image (A from BSAVE)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BAS
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Load address for program image (when SAVEd)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
VAR
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Address of compressed variables images (when STOREd)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
SYS
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Load address for system program (usually $2000)
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$21–$24
</td>
<td align="justify" valign="top" style="width: 60%;">
LAST_MOD: Date and time at which file was last modified. This field is zero if no date was assigned. Format is identical to CREATION above.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
$25–$26
</td>
<td align="justify" valign="top" style="width: 60%;">
HEADER_POINTER: Block number of the key block for the directory which describes this file.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="justify" valign="top" style="width: 60%;">

</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
Figure 4.6 is an example of a typical Volume Directory block for the example introduced with Figure 4.2. In this case, there are only three files on the diskette so only the first three directory entries are filled in. The remaining directory entries have never been used and contain zeroes.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.3">4.3</a> File Structures
</h2>
<div class="Unindented">
One of ProDOS’s major jobs is to keep track of the blocks which make up a file. When programming, the user need never know that a file is actually made up of one or more blocks scattered far and wide all over the diskette volume. ProDOS must make the file appear to the programmer to be a continuous stream of sequential data.
</div>
<div class="Indented">
So far the files shown in the examples here have only had one block. This was done to avoid complicating the discussion of the Volume Directory. In practice, however, very few files are 512 bytes or less in length. ProDOS defines three file structures to handle files of different sizes:
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top">
The Seedling
</td>
<td align="left" valign="top">
–
</td>
<td align="justify" valign="top" style="width: 7cm;">
for files of 512 bytes or less
</td>

</tr>
<tr>
<td align="left" valign="top">
The Sapling
</td>
<td align="left" valign="top">
–
</td>
<td align="justify" valign="top" style="width: 7cm;">
for files with more than 512 bytes but less than 128K
</td>

</tr>
<tr>
<td align="left" valign="top">
The Tree
</td>
<td align="left" valign="top">
–
</td>
<td align="justify" valign="top" style="width: 7cm;">
for files with more than 128K bytes of data up to 16 megabytes (16,777,216 bytes)
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
Examples of <b>seedling</b> files have already been shown. A seeding file consists of a single <b>data block</b> whose number is stored in the KEY_POINTER field in the file entry of the directory. Thus, a seedling file, by definition, costs only one block of storage (and a file descriptive entry).
</div>
<div class="Indented">
For the purposes of this discussion, let us assume that we had run the following Applesoft BASIC program against our example disk volume from Figure 4-2.
</div>
<pre class="LyX-Code">
10 PRINT CHR$(4);"OPEN TXTFILE,L64" 
20 FOR I=0 TO 2 
30 PRINT CHR$(4);"WRITE TXTFILE,R";I 
40 PRINT "RECORD";I 
50 NEXT I 
60 PRINT CHR$(4);"CLOSE TXTFILE" 
70 END
</pre>
<div class="Unindented">
This program creates the TXT file, &ldquo;TXTFILE&rdquo;, with a record length of 64 bytes. It then writes three records containing the strings &ldquo;RECORD0&rdquo;, &ldquo;RECORD1&rdquo;, and &ldquo;RECORD2&rdquo;. The total size of this file is then 3 times 64 or 192 bytes. Since this is less than 512 bytes, the file is stored as a seedling.
</div>
<div class="Indented">
Now, assume that statement 20 is changed to read:
</div>
<pre class="LyX-Code">
20 FOR I=0 TO 100 
</pre>
<div class="Unindented">
and the program is rerun. The file it creates will now contain 101 records of 64 bytes each, so the total size is 6464 bytes. As the ninth record is written (RECORD8), ProDOS discovers that the original seedling block is full. There is no room in the directory to store another block number, so ProDOS creates what is called an <b>index block</b>. This block contains the block numbers of each data block in the file in the order that they should be accessed. Using an index block, ProDOS can describe the file in a sequential and orderly way, even though its data blocks may not be physically contiguous (next to one another on the diskette). For example, if the previous data block in a file was 47, it is not necessary to store the data which follows it in block 48. Instead, any free block located anywhere on the diskette may be used simply by placing its block number next to 47’s in the index block.
</div>
<div class="Indented">
Thus, in our example, a new block is allocated to be the index block ($A), another new block is allocated to be the second data block ($B), both the original data block’s number and the new data block’s number are placed in the new index block, and, finally, the directory entry for the file is updated so that it now points to the index block instead of the seedling data block. Of course, the STORAGE_TYPE field in the directory entry must also be changed to indicate that this is now a <b>sapling</b> file and is no longer a seedling. Index block entries which are not associated with any data block yet (such as those beyond the end of file position) are set to zeroes. Since a block is 512 bytes long and the block numbers require a 2-byte field, this index block can store pointers to up to 256 data blocks representing up to 131072 bytes of data (128K). Obviously, most files will fall within this class of file structure. A diagram of the general form of a sapling file is given in Figure 4.7.
</div>
<div class="Indented">
The index block for TXTFILE is given in Figure 4.8. Notice that the first block of the file is still block 8, the original data block of the old seedling version of TXTFILE. Notice also that in an index block, the least significant byte of the block numbers are stored in the first half of the block, and the most significant (in this example all MSB’s are $00) in the last half. This was done to simplify indexing into the block (the 6502 index registers can only index up to 256 bytes at a time). Thus, to find any given block, one must assemble a block number by picking the Nth byte and the N + 256th byte in the index block where N is the relative block desired.
</div>
<div class="Indented">
Suppose that we now modify our program again so that 2144 records will be written. This pushes the total file size up to 137,216, more than can be described by a single index block. ProDOS must &ldquo;promote&rdquo; the file to the next level of the hierarchy, a <b>tree</b> file. A <b>tree</b> file consists of a single <b>master index block</b>, pointed to by the directory entry, which, in turn, contains the block numbers of two or more other index blocks. These lower level index blocks contain the actual data block numbers. This structure is diagrammed in figure 4.9. Thus, since the master index block can describe 256 &ldquo;subindex&rdquo; blocks, and each subindex block can describe 256 data blocks, in principle this structure would support files of up to 32 megabytes! In order to limit block numbers to a 2-byte signed value of 32767, however, an arbitrary upper limit of 16 megabytes was imposed. In other words, a master index block can never be more than half full.
</div>
<div class="Indented">
The entire structure for TXTFILE is depicted in Figure 4.10. Note that the original index block of the sapling file (block $A) became the first subindex block of the tree file. Also, when the changeover was made, the master index block was allocated first ($10A), then the second subindex block ($10B), and finally the data block whose allocation made the file into a tree ($10C). The last block allocated is for RECORD2136 through RECORD2143 (for a total of 2144 records). This is the last block on the diskette ($117), and, since no blocks were ever freed, the diskette is now full. Although TXTFILE has only two subindex blocks and it is nearly as large as diskette, this does not imply that all tree files will have two subindex blocks, as will become apparent when sparse files are discussed.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.4">4.4</a> File Data Types
</h2>
<div class="Unindented">
Unless they are directories (or DIR type files), all files conform to one of three file structures described above even though the data in files may have different intended uses. A file might contain an Applesoft BASIC program which was SAVEd in addition to being a sapling file. It might be a binary memory image which was BSAVEd and conforms to the seedling structure. Or it might be data for a BASIC program in a TXT file and have the tree characteristic. File types, such as BAS, TXT, or SYS are less important to ProDOS than they are to the programs which use the files. This means that the basic structure of a BAS file is identical to that of a BIN file — only the interpretation of the data differs. ProDOS maintains a consistent set of file types by convention, and to a limited extent, the BASIC command interpreter enforces these conventions (e.g., &ldquo;FILE TYPE MISMATCH&rdquo;). You are not prevented, however, from storing an Applesoft BASIC program image in a TXT file if you really work at it!
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.4.1">4.4.1</a> TXT Files
</h3>
<div class="Unindented">
The TXT or text file in its <b>sequential</b> form is the least complicated file data type (in its random form, it is, perhaps, the most complex). A sequential TXT file consists of one or more records, separated from each other by carriage return characters (hex $0D’s). This structure is shown and an example file is given in Figure 4.11. Usually, the end of a TXT file is signaled by the End Of File (EOF) position stored in the directory entry for the file. Since $0D is used to delimit records, carriage returns should not appear within a record. Usually, only valid ASCII characters are allowed in a TXT file to make them accessible to BASIC programs (i.e. printable text, numerics or special characters; refer to p.8 of the <i>Apple II Reference Manual</i> or p. 16 of the <i>Apple II Reference Manual for IIe Only</i>). This restriction makes processing of a TXT file slower and less efficient in the use of disk space than with a BIN or VAR type file, since each digit must occupy a full byte in the file.
</div>
<div class="Indented">
When TXT files are accessed <b>randomly</b>, or by record number, &ldquo;holes&rdquo; can appear between records. In the example given earlier and in Figure 4.12, each record is allocated 64 bytes of space in the file. By doing this, it is easy to find any record by multiplying its number by 64 and using this as a byte offset into the file. The record length is chosen as the maximum amount of space any record might occupy. Thus, records with less than 64 bytes of data, such as the ones in the example, will have wasted space at their end (filled in this case with $00s). This wasted space is called padding. The actual data in each record is terminated with a $0D (carriage return) just as in the sequential text file record (allowing BASIC to read it as a single INPUT line). In this way, data within a single record can be accessed as if it was a miniature sequential TXT file. In an attempt is made to sequentially read beyond into the padding, a null string is returned.
</div>
<div class="Indented">
When the randomly organized file is SAVEd, the record length given with the &ldquo;L&rdquo; keyword is stored in the AUX_TYPE field in the directory entry for the file. Then, if later OPENs omit this keyword, the original value can be supplied by ProDOS.
</div>
<div class="Indented">
Notice that in the example in Figure 4.12, record 3 has not been initialized. Indeed, none of the other records following RECORD2 have anything but $00s in them. By WRITEing to specific records in a non-sequential order, it is possible to leave very large holes between records which contain data. Such files are called &ldquo;sparse.&rdquo; If a hole falls within a block which has other records which contain data, it is represented by binary zeroes. But if the hole covers entire blocks, ProDOS does not bother to allocate them at all. There is no point in wasting disk space on holes! Thus, if the next record containing data in our example was RECORD25, for instance, the rest of block 0 would contain zeroes (as it does now), no block would be allocated for block 1 or block 2, and block 3 would contain zeroes until the position of RECORD25 was reached. This is diagrammed in Figure 4.13. Notice that the positions of the &ldquo;phantom&rdquo; blocks are marked in the file’s index block with zeros. Thus, although the files covers a &ldquo;data space&rdquo; of six blocks, only three data blocks are actually allocated. It is possible to create a file with only two data blocks which covers the entire 16-megabyte data space. Such a file would incorporate one master index block with an entry at +0 and at +7F. All the subindex blocks in between would be &ldquo;phantom,&rdquo; or not allocated and marked with zero pointers. The first index block would contain a single entry at +0 for the first data block. And the last index would contain a single entry at +FF for the last data block. A 16-megabyte file using only five blocks of disk space!
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.4.2">4.4.2</a> Bin Files
</h3>
<div class="Unindented">
The structure of a BIN type file is shown in figure 4.14. An exact copy of the memory selected is written to the disk blocks(s). The original address from which the memory was copied is stored in the AUX_TYPE field of the directory entry for the file. The EOF position in the directory records the length of the binary image. These values are those given in the A and L (or E) keywords of the BSAVE command which created the file. ProDOS can be made to BLOAD or BRUN the image at a different address by specifying the A (address) keyword when the command is entered, or by changing the address in the directory entry (this is sometimes necessary if the file cannot be BSAVEd from the location where it will run, such as from the screen buffer).
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.4.3">4.4.3</a> BAS Files
</h3>
<div class="Unindented">
A BASIC program is saved to the diskette in a way that is nearly identical to BSAVE. The format of a BAS file is given in Figure 4.15. When the SAVE command is typed, the ProDOS BASIC command interpreter determines the location of the BASIC program in memory and its length by examining Applesoft’s zero page address. An image of the program is written to the file, and, again, the AUX_TYPE and EOF fields of the directory entry represent the address and length. Notice that the character representation of the program is somewhat garbled. This is because, in the interest of saving memory, BASIC &ldquo;tokenizes&rdquo; the program. Reserved BASIC words, such as PRINT, IF, END, or CHR$, are replaced with a single hexadecimal code value (set off from other characters by its most significant bit being forced on). A complete treatment of the appearance of a BASIC program in memory is outside the scope of this manual, but a partial breakdown of the program in Figure 4.15 is given.
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-4.4.4">4.4.4</a> Other File Types (VAR, REL, SYS)
</h3>
<div class="Unindented">
Several other file types have been set aside by ProDOS. Many are those found in the SOS operating system (e.g. PCD, PTX, PDA for Pascal, etc.). These are listed in APPENDIX E and will not be covered here since they are not indigenous to ProDOS. Other ProDOS file types include BAD and CMD. BAD files are obviously intended to mark permanent I/O errors on a disk’s surface from accidental use, but there seem to be no utilities within ProDOS 1.0 which create them. The CMD and PAS file types are not currently supported by the ProDOS BASIC command interpreter, so their planned structures are anyone’s guess. AppleWorks file types are designed for the AppleWorks package, and their structures are specific to that package. The formats of the VAR, REL, and SYS files are defined, however.
</div>
<div class="Indented">
The VAR filetype is used to store the contents of a BASIC program’s variables using the STORE command. The ProDOS BASIC command interpreter compresses all of the strings together with the numeric variables and saves the resulting chunk of memory as a VAR file. The first five bytes of the file constitute a header which defines the memory image that follows:
</div>
<div class="Indented">
<span class="unknown">\medskip</span> 
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
Var File Header
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
Byte Offset
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Length
</div>

</td>
<td align="justify" valign="top" style="width: 7cm;">
<div class="PlainVisible">
Description
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
+0
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(2 bytes)
</div>

</td>
<td align="justify" valign="top" style="width: 7cm;">
<div class="PlainVisible">
Combined length of simple and array variables
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
+2
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(2 bytes)
</div>

</td>
<td align="justify" valign="top" style="width: 7cm;">
<div class="PlainVisible">
Length of simple variables only
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
+4
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(1 byte)
</div>

</td>
<td align="justify" valign="top" style="width: 7cm;">
<div class="PlainVisible">
MSB of HIMEM when these variables were STOREd
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
+5
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(n bytes)
</div>

</td>
<td align="justify" valign="top" style="width: 7cm;">
<div class="PlainVisible">
Start of memory image\SpecialChar ldots
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
The AUX_TYPE field of the directory entry for the file contains the starting address from which the compressed variables were copied. EOF is an indication of the end of the image. When a RESTORE is later issued, the memory image is reloaded, the strings are separated from the rest of the variables, and, if necessary, string pointers are adjusted based on the new HIMEM value.
</div>
<div class="Indented">
The REL file type is used with a special form of binary file, containing the memory image of a machine language program which may be relocated anywhere in memory based upon additional information stored with the image itself. Such a file is called a Relocatable Object Module File and is produced as output from the Apple Toolkit Assembler (EDASM). The format for this type of file is given in the documentation accompanying the assembler.
</div>
<div class="Indented">
A SYS, or system file, is just like a BIN file except that it nearly always loads at $2000 and implies a reload of the command interpreter after it exits. SYS files are invoked with the &ldquo;-&rdquo;, or smart RUN command, from the BASIC command interpreter. The interpreter closes all open files, frees all of the memory occupied by itself, and does a standard BRUN at $2000.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.5">4.5</a> DIR Files — ProDOS Subdirectories
</h2>
<div class="Unindented">
Since the Volume Directory has room for just 51 entries, without subdirectories, you would be limited to 51 files per volume. This may not seem to be much of a hardship on a diskette (although it might, since DOS 3.3 allows 105), but on a hard disk with 5 million bytes or more this limit is unthinkable. In order to create a more dynamic and flexible structure, the user is permitted to create subdirectories. A <b>subdirectory</b> can be thought of as an extension to the Volume Directory, but there is more to it than that. In the simplest case, a subdirectory is created and an entry which describes it is placed in the Volume Directory. The subdirectory has a structure very similar to the Volume Directory: it has a header entry located at its beginning; its blocks are doubly linked by pointers in the first four bytes of each block; and it can contain file descriptive entries (including entries for &ldquo;sub-subdirectories&rdquo;). Unlike the Volume Directory, however, it can be of any length (it starts out with only a single block and more are added as required), its header has a slightly different format, it can be located anywhere on the diskette, and its blocks are not necessary contiguous. A diagram of a typical subdirectory is shown in Figure 4.16. Thus, within a single subdirectory, you can create as many file entries as you have disk blocks! In practice, however, it is usually more convenient to create multiple subdirectories &ldquo;dangling&rdquo; from the Volume Directory, each for a specific purpose (e.g. one for word processing, one for program development, one for spreadsheets, and so on). These subdirectories might even be thought of as miniature &ldquo;diskettes&rdquo; within the larger volume. Although it is possible to set up very complex structures using subdirectories (multiple level tree-like networks), usually this is not very efficient or convenient and a single level (all subdirectories linked directly to the Volume Directory) works best.
</div>
<div class="Indented">
One of the major concepts around which ProDOS was designed is the notion of a <b>path</b> to a file. Ordinarily, if a file is described by the Volume Directory, this path is very simple. ProDOS merely looks up the file in the Volume Directory and that is that. If the file is described by a subdirectory, however, ProDOS insists upon knowing how to find the subdirectory. Of course, ProDOS could systematically search all subdirectories for the file and all subdirectories of the subdirectories, and so on, but this would be very time consuming (especially if you had mistyped the file name and it didn’t really exist!). Since the user usually knows which subdirectory contains the file (and, perhaps, which subdirectory describes that subdirectory, etc.) the practice is to tell ProDOS what path to follow to find a file. This is done by first specifying the volume to be searched, thereby naming the Volume Directory, followed by a list of all subdirectories which must be traversed to eventually find the file, and finally by the file name itself. For example, if in Figure 4.16 the volume name is &ldquo;VOLUME&rdquo; and the subdirectory is &ldquo;SUB&rdquo; and the file described by the subdirectory is &ldquo;FILE,&rdquo; the path to find that file would be: \begin_inset Separator latexpar\end_inset
</div>
<div class="Indented">
<div class="center">
/VOLUME/SUB/FILE
</div>

</div>
<div class="Indented">
If the file described by the Volume Directory in Figure 4.16 was also called &ldquo;FILE&rdquo; there would be no confusion at all, because its pathname would be unique: \begin_inset Separator latexpar\end_inset
</div>
<div class="Indented">
<div class="center">
/VOLUME/FILE
</div>

</div>
<div class="Indented">
This points out an additional advantage of subdirectories. It was mentioned earlier that they were like miniature &ldquo;diskettes,&rdquo; and, just like diskettes, there is no problem in using identical file names within different directories.
</div>
<div class="Indented">
To make specifying pathnames easier, the user can specify a default prefix to ProDOS. When a file name is given (without a leading &ldquo;/&rdquo; in its name) it is assumed to be an incomplete pathname. To complete it, ProDOS merely attaches the prefix to the beginning. Thus, if the current prefix is: /VOLUME/SUB And a reference was made to &ldquo;FILE,&rdquo; ProDOS would create the following fully qualified pathname: \begin_inset Separator latexpar\end_inset
</div>
<div class="Indented">
<div class="center">
/VOLUME/SUB/FILE
</div>

</div>
<div class="Indented">
Therefore, be specifying a prefix you are, in a sense, stating that you wish to work within a specific &ldquo;miniature diskette,&rdquo; although you can still access any other file on the volume by giving its complete pathname explicitly.
</div>
<div class="Indented">
An examples of a typical subdirectory block is given in Figure 4.17. The format of the Subdirectory Header is given below (remember that the first four bytes of each subdirectory block contain the previous and next block numbers respectively):
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" colspan="1">
Block Byte
</td>
<td align="justify" valign="top" style="width: 9cm;" colspan="1">
Description
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="1">

</td>
<td align="justify" valign="top" style="width: 9cm;">

</td>

</tr>
<tr>
<td align="left" valign="top">
$04
</td>
<td align="justify" valign="top" style="width: 9cm;">
STORAGE_TYPE/NAME_LENGTH: The first nibble (top 4 bits) of this byte describes the type of entry. In this case, this is a Subdirectory Header so this nibble is $E. The low 4 bits are the length of the name in the next field (the subdirectory name).
</td>

</tr>
<tr>
<td align="left" valign="top">
$05–$013
</td>
<td align="justify" valign="top" style="width: 9cm;">
SUBDIR_NAME: A 15-byte field containing the name of this subdirectory. The actual length is defined by NAME_LENGTH above; the remainder of the field is ignored.
</td>

</tr>
<tr>
<td align="left" valign="top">
$14
</td>
<td align="justify" valign="top" style="width: 9cm;">
$14 must contain $75.
</td>

</tr>
<tr>
<td align="left" valign="top">
$15–$1B
</td>
<td align="justify" valign="top" style="width: 9cm;">
Reserved for future use.
</td>

</tr>
<tr>
<td align="left" valign="top">
$1C–$1F
</td>
<td align="justify" valign="top" style="width: 9cm;">
CREATION: The date and time of the creation of this file. This field is zero if no date was assigned. The format of the field is as follows:
</td>

</tr>
<tr>
<td align="left" valign="top" colspan="2">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BYTE 0 and 1
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
–
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
yyyyyyymmmmddddd
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
year/month/day
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
BYTE 2 and 3
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
–
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
000hhhhh00mmmmmm
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
hours/minutes
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="justify" valign="top" style="width: 9cm;">
where each letter above represents one binary bit. This is the standard form for all create and modify date/time stamps in directories.
</td>

</tr>
<tr>
<td align="left" valign="top">
$20
</td>
<td align="justify" valign="top" style="width: 9cm;">
VERSION: the ProDOS version number under which this subdirectory was created. This field tells later version ofd ProDOS not to expect to find any fields which were defined by Apple after this version of ProDOS was released. This fiend indicates the level of upward compatability between versions. Under ProDOS 1.0, it’s value is zero.
</td>

</tr>
<tr>
<td align="left" valign="top">
$21
</td>
<td align="justify" valign="top" style="width: 9cm;">
MIN_VERSION: Minimum version of ProDOS which can access this subdirectory. A cakue in this field implies that significant changes were made to the field definitions since prior version of ProDOS were in use and these older versions would not be able to successfully interpret the structure of this subdirectory. This field indicates the level of downward compatability between versions. Under ProDOS 1.0, its value is zero.
</td>

</tr>
<tr>
<td align="left" valign="top">
$22
</td>
<td align="justify" valign="top" style="width: 9cm;">
<div class="PlainVisible">
ACCESS: The bits in this flag byte define how the directory may be accessed. The bit assignments are as follows:<br>

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">

</div>
<div class="PlainVisible">
$80 – Subdirectory may be destroyed (deleted)<br>
$40 – Subdirectory may be renamed<br>
$20 – Subdirectory has changed since last backup<br>
$02 – Subdirectory may be written to
</div>
<div class="PlainVisible">
$01 – Subdirectory may be read<br>

</div>
<div class="PlainVisible">
All other bits are reserved for future use.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
$23
</td>
<td align="justify" valign="top" style="width: 9cm;">
ENTRY_LENGTH: Length of each entry in the Subdirectory in bytes (usually $27)
</td>

</tr>
<tr>
<td align="left" valign="top">
$24
</td>
<td align="justify" valign="top" style="width: 9cm;">
ENTRIES_PER_BLOCK: Number of entries in each block of the Subdirectory (usually $0D). Note that the Subdirectory Header is considered to be an entry.
</td>

</tr>
<tr>
<td align="left" valign="top">
$25–$26
</td>
<td align="justify" valign="top" style="width: 9cm;">
FILE_COUNT: Number of active entries in the Subdirectory. An actice entry is one which describes a file or subdirectory which has not been deleted. This count does not include the subdirectory Header. Note that this field’s name is a bit misleading since the count also includes the count also includes other subdirectory entries.
</td>

</tr>
<tr>
<td align="left" valign="top">
$27–$28
</td>
<td align="justify" valign="top" style="width: 9cm;">
<div class="PlainVisible">
PARENT_POINTER: The block number of the key (first) bblock of the directory which contains the entry which describes this subdirectory.
</div>
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
$29
</td>
<td align="justify" valign="top" style="width: 9cm;">
PARENT_ENTRY: The entry number within the parent directory which describes this subdirectory (the parent directory’s header counts as zero).
</td>

</tr>
<tr>
<td align="left" valign="top">
$2A
</td>
<td align="justify" valign="top" style="width: 9cm;">
PARENT_ENTRY_LENGTH: The length of entries in the parent directory in bytes (usually $27).
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="justify" valign="top" style="width: 9cm;">

</td>

</tr>

</table>

</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.6">4.6</a> Emergency Repairs
</h2>
<div class="Unindented">
From time to time the information on a diskette can become damaged or lost. This can create various symptoms, ranging from mild side effects, such as the diskette not booting, to major problems, such as an input/output (I/O) error in the Volume Directory. A good understanding of the format of a diskette, as described previously, and a few program tools can allow any reasonably sharp Apple II user to patch up most errors on his diskettes.
</div>
<div class="Indented">
A first question would be, &ldquo;how do errors occur?&rdquo; The most common cause of an error is a worn or physically damaged diskette. Usually a diskette will warn you that it is wearing out by producing &ldquo;soft errors.&rdquo; Soft errors are I/O errors which occur randomly. You may get an I/O error message when you CATALOG a disk one time and have it CATALOG correctly if you try again. When this happens, a smart programmer immediately copies the files on the aged diskette to a brand new one and discards the old one or keeps it as a backup.
</div>
<div class="Indented">
Another cause of damaged diskettes is the practice of hitting the RESET key to abort the execution of a program which is accessing the diskette. Damage will usually occur when the RESET signal comes just as data is being written onto the disk. Powering the machine off just as data is being written to the disk is also a sure way to clobber a diskette. Of course, real hardware problems in the disk drive, cable, or controller card can cause damage as well.
</div>
<div class="Indented">
If the damaged disk can be CATALOGed, recovery is much easier. A damaged ProDOS bootstrap loader on track 0 can usually be corrected by formatting a fresh diskette and copying the files from the old one to the new one. If only one files produces an I/O ERROR when it is used, it may be possible to copy most of the sectors of the file to another diskette by skipping over the bad sector with an assembler language program which calls the MLI (Machine Language Interface) in the ProDOS Kernel, or with a BASIC program (if the file is a TXT file). Indeed, if the problem is a bad checksum (see Chapter 3), it may be possible to read the bad sector and ignore the error and get most of the data.
</div>
<div class="Indented">
An I/O error usually means that one of two conditions has occurred. Either a bad checksum was detected on the data in a sector, meaning that all bytes in the sector which follow the point of damage may be lost; or the sectoring is clobbered such that the sector no longer even exist on the diskette. If the latter is the case, the diskette (or at the very least, the track) must be reformatted, resulting in a massive loss of data. Although a program can be written to format a single track (see APPENDIX A), it is usually easier to copy all readable sectors from the damaged diskette to another formatted diskette and then reconstruct the lost data there.
</div>
<div class="Indented">
Disk utilities, such as Quality Software’s <i>Bag of Tricks</i>, allow the user to read and display the contents of sectors or blocks. <i>Bag of Tricks</i> will also allow you to modify the sector data and rewrite it to the same or another diskette. If you do not have <i>Bag of Tricks</i> or another commercial disk utility, you can use the ZAP program in APPENDIX A of this book. The ZAP program will read any block of an unprotected disk into memory, allowing the user to examine it or modify the data and then, optionally, rewrite it to a disk. Using such a program is very important when learning about diskette formats and when fixing clobbered data.
</div>
<div class="Indented">
Using ZAP, a bad sector within a file can be localized by reading each block listed in the index blocks for that file. If the bad block is in a directory, the pointers of up to 13 files may be lost. When this occurs, a search of the diskette can be made to find ‘‘homeless’’ index blocks (ones which are not otherwise connected to the remaining good directory blocks in that and other directories). As these index blocks are found, new file descriptive entries can be made in the damaged sector which point to these blocks. Of course, it helps to know whether the lost files are seedlings, saplings, or trees! When the entire Volume Directory is lost, this process can take hours, even with a good understanding of the format of ProDOS volumes. Such an endeavor should only be undertaken if there is no other way to recover the data. Of course, the best policy is to create backup copies of important files periodically to simplify recovery. More information on the above procedures is given in APPENDIX A.
</div>
<div class="Indented">
A less significant but very annoying form of diskette clobber is the loss of free blocks. It is possible, by powering off or hitting RESET at the wrong time, to leave blocks marked in use in the Volume Bit Map which were about to be marked free. These lost blocks can never be recovered by normal means, even when files are deleted, since they do not belong to anyone. The result is a DISK FULL message before the volume is actually full. to reclaim the lost block, it is necessary to compare every block listed in every index block or directory against the Volume Bit Map to see if there are any discrepancies. There are utility programs which will do this automatically, but the best way to solve this problem is to copy all the files on the diskette to another diskette (note that the diskette must be copied on a file by file basis, not as a volume, since a volume copy would copy an image of the diskette, bad Volume Bit Map and all).
</div>
<div class="Indented">
If a file is deleted, it can usually be recovered, providing that additional block allocations have not occurred since it was deleted. If another file was created after the DELETE command, ProDOS probably has reused some or all of the blocks of the old file. The appropriate directory can be quickly ZAPped to reactivate the file (you will have to guess at the STORAGE_TYPE and NAME_LENGTH values) at +0 in the deleted entry. The file should then be copied to another diskette and then the original deleted so that the Volume Bit Map will be correct.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-4.7">4.7</a> Fragmentation
</h2>
<div class="Unindented">
ProDOS overhead in reading or writing blocks to a volume consists of three main parts:
</div>
<ol>
<li>
ProDOS computational overhead time (The time to get ready to access the disk). 
</li>
<li>
Seek time (moving the disk arm to the proper track). 
</li>
<li>
Rotational delay (waiting for the proper sector to appear under the disk head).
</li>

</ol>
<div class="Unindented">
In the first respect, ProDOS is an enormous improvement over Apple’s earlier operating system, DOS, being up to eight times faster in its operation. This fact only increases the significance of the other two delay areas. Skewing can have an effect on rotational delay to some extent (see Chapter 3), but is much more difficult to control. Seek time, however, can vary greatly depending upon use patterns and the arrangement of files on a volume.
</div>
<div class="Indented">
Imagine, for example, a volume on which a great deal of activity has occurred. Many files have been created and deleted over a period of time, leaving &ldquo;holes&rdquo; here and there as files are deleted, which are reallocated to existing or new files as necessary. Eventually, a map of the volume looks like a plate of spaghetti! There is nothing really wrong with this — files can be accessed normally — but if parts of an otherwise short file are spread all over the disk volume, ProDOS must spend a lot of time moving the disk read/write head from track to track to pick up all the pieces in the proper order. This costs time. A disk volume in this state of affairs is said to be badly &ldquo;fragmented.&rdquo; Fragmentation can be even more important on a hard disk since the ratio of seek delay to rotational delay is much greater. Likewise, the best skewing setup in the world can be completely gutted by a fragmented disk, since few sequential files sectors are found together on the same track, and as the arm is moved to the new track, there is no telling how long the rotational delay will be.
</div>
<div class="Indented">
When disk access time becomes a concern, it is sometimes useful to intelligently move move files to specific spots on the disk. To accomplish this, the user must format a new, blank volume and copy the files from the old disk, one by one, to the new disk in an appropriate order. Remember that ProDOS allocates blocks for files in numerically increasing order (from the outside track of the disk to the inside track). Thus, the first file you copy will be placed near the Volume Directory (a good place if you want to find that file fast). The last file you copy will go closest to the center hub of the diskette. If your program accesses two files at once, try to place them near one another on the disk. Do not separate them by many other files or you will hear the disk arm &ldquo;thrashing&rdquo; back and forth as it first accesses a block in file A and then must access one in file B. While you hear that noise, your program is not doing anything useful! Another thing to remember if your program opens and closes files frequently is that, when it does so, it may access several directories. It is usually a good idea in any case to keep all of your directories squashed down against the Volume Directory (i.e. CREATE all directories before you copy any files onto the new diskette) so that pathname searches will go faster.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-5">5</a> The Structure Of ProDOS
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-5.1">5.1</a> ProDOS Memory Use
</h2>
<div class="Unindented">
ProDOS is an assembly language program which is loaded into RAM memory when the user boots his disk. Although the ProDOS machine language support routines can run by themselves in a machine smaller than 64K (or 48K plus a language card), ProDOS is primarily intended to run only on a full sized 64K or larger Apple II Plus or an Apple IIe or IIc. In a 64K Apple II, ProDOS normally occupies the 16K of bank switched memory (or the Language Card for older Apples) and about 10.5K at the top of main memory ($9600 through $BFFF). The part of ProDOS which occupies the bank switched memory is called the <b>Kernel</b>. The part occupying the top of main memory is called the <b>BASIC Interpreter</b> (BI). The Kernel consists of support subroutines which may be called by any assembly language program (such as the BASIC Interpreter) to access the disk, either block by block or file by file. The BASIC Interpreter accepts ProDOS commands entered by the user or his programs, and translates them into calls to the Kernel subroutines<span class="FootOuter"><span class="SupFootMarker"> [D] </span><span class="HoverFoot"><span class="SupFootMarker"> [D] </span>It is possible, if the BASIC Interpreter’s functions are not required by an application (such as a stand alone arcade-type game), to separate the Kernel from the BASIC Interpreter and not even load the BASIC Interpreter. For the purposes of this discussion, however, we will assume that ProDOS consists of both the Kernel and the BASIC Interpreter. In addition, the ProDOS Kernel may be loaded into the main part of memory if the Apple does not have a language card (48K Apple II), but the BASIC Interpreter may not be used under these circumstances because it cannot be relocated.</span></span>. When the BASIC Interpreter is loaded, ProDOS must fool Applesoft BASIC into believing that there is actually less RAM in the machine than there is. With ProDOS loaded, Applesoft believes that there is only about 38K of RAM. ProDOS does this by adjusting HIMEM after it has loaded the BASIC Interpreter to prevent Applesoft from using the memory ProDOS is occupying. In order to keep track of the memory it is using, ProDOS maintains a &ldquo;bit map&rdquo; table which describes every page (256 bytes) in memory and marks it either free or in use. By examining this table, user written programs can avoid using previously assigned memory, even if later versions of ProDOS are loaded elsewhere. 
</div>
<div class="Indented">
A diagram of ProDOS’s memory is given in figure 5.1. As can be seen, there are numerous subdivisions of the two basic components mentioned above. In addition, there are two special <b>global pages</b> containing the addresses and data pertaining to the ProDOS Kernel (SYSTEM GLOBAL PAGE ar $BF00) and the BASIC Interpreter (BI GLOBAL PAGE at $BE00) which may be of interest to external user written programs. These global pages will be discussed in more detail later in this chapter.
</div>
<div class="Indented">
As discussed earlier, ProDOS can be divided into two major components: the Kernel, containing the <b>Machine Language Interface (MLI)</b>; and the BASIC Interpreter (BI). In theory, other interpreters could be written and substituted for the BI (to support Pascal or C language development, for example) but at present the only interpreter provided by Apple is the BASIC Interpreter, supporting Applesoft BASIC. 
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-6">6</a> Using ProDOS From Assembly Language
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-6.1">6.1</a> Caveat
</h2>
<div class="Unindented">
This chapter is aimed at the advanced assembly language programmer who wishes to access the disk at any level. Access to the disk by BASIC programs is well documented in the ProDOS manual, <i>BASIC Programming With ProDOS</i>. The material presented in this chapter may be beyond the comprehension (at least for the present) of a programmer who has never used assembly language.
</div>
<div class="Indented">
Access to a diskette from assembly language may be accomplished at four different levels:
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top">
Level 0
</td>
<td align="left" valign="top">
Direct access of the diskette controller
</td>

</tr>
<tr>
<td align="left" valign="top">
Level 1
</td>
<td align="left" valign="top">
Block access
</td>

</tr>
<tr>
<td align="left" valign="top">
Level 2
</td>
<td align="left" valign="top">
Machine Language Interface (MLI) access
</td>

</tr>
<tr>
<td align="left" valign="top">
Level 3
</td>
<td align="left" valign="top">
BI command access
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
At the lowest level is direct access of the diskette controller. Here, data is accessed byte by byte. This may be required to implement diskette protection schemes or to perform low level diagnostic or correction of I/O errors. The next level of access is by ProDOS blocks (two sectors per block). This is done using the appropriate ProDOS device driver; in this case, the diskette device driver. At a higher level still is the ProDOS Machine Language Interface (MLI). Here, data may be accessed on a file basis. Finally, the highest level if access is through the ProDOS BASIC Interpreter. Here, entire ProDOS command lines may be executed to produce formatted directory listings and the like. A detailed description od the programming considerations at each of these levels follows. 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.2">6.2</a> Direct Use Of The Diskette Drive
</h2>
<div class="Unindented">
It is often desirable or necessary to access the Apple’s disk drives directly from assembly language, ithout the use of ProDOS. Applications which might use direct disk access range from a user written operating system to ProDOS-independent utility programs. Direct access is accomplished using 16 addresses that provide eight on/off switches which directly control the hardware. For information on the disk hardware, please refer to Appendix D. The device Address assignments are given in Table 6.1.
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
Table 6.1 ProDOS Hardware Addresses
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top" colspan="2">
<div class="PlainVisible">
&ldquo;Off&rdquo; Switches
</div>

</td>
<td align="left" valign="top" colspan="2">
<div class="PlainVisible">
&ldquo;On&rdquo; Switches
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Base
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Base
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Switch
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Address
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Function
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Address
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Function
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q0
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C080
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 0 off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C081
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 0 on
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q1
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C082
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 1 off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C083
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 1 on
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q2
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C084
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 2 off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C085
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 2 on
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q3
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C086
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 3 off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C087
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Phase 3 on
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q4
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C088
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Drive off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C089
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Drive on
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q5
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08A
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Select drive 1
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08B
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Select drive 2
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q6
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08C
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Shift Data Register
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08D
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Load Data Register
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q7
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08E
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Read
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C08F
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Write
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<div class="Indented">
The last to switches are difficult to explain in single phrase definitions because they interact with each other forming a 4-way switch. The four possible settings are given in Table 6.2.
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
Table 6.2 Four Way Q6/Q7 Switches
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Q6
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Q7
</div>

</td>
<td align="justify" valign="top" style="width: 5cm;">
<div class="PlainVisible">
Function
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Off
</div>

</td>
<td align="justify" valign="top" style="width: 5cm;">
<div class="PlainVisible">
Enable Read Sequencing.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Off
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
On
</div>

</td>
<td align="justify" valign="top" style="width: 5cm;">
<div class="PlainVisible">
Shift data register every four cycles while writing.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
On
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Off
</div>

</td>
<td align="justify" valign="top" style="width: 5cm;">
<div class="PlainVisible">
Check write protect and initialize sequencer for writing.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
On
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
On
</div>

</td>
<td align="justify" valign="top" style="width: 5cm;">
<div class="PlainVisible">
Load data register every four cycles while writing.
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<div class="Indented">
The addresses are slot dependent and the offsets are computed by multiplying the slot number by 16. In hexadecimal this works out nicely. Simply add the value $s0 (where s is the slot number) to the base address. To engage disk drive number 1 in slot number 6, for example, we would add $60 to $C08A (device address for engaging drive 1) for a result ot $C0EA. However, since it is generally desirable to write code that is not slot dependent, one would normally use $C08A,X (where the X-register contains the value $s0). Table 6.3 shows the range of addresses for each slot number.
</div>
<div class="Indented">
span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
Table 6.3 Address Ranges For Slots
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="center" valign="top" colspan="1">
<div class="PlainVisible">
Slot 
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Address 
</div>

</td>

</tr>
<tr>
<td align="center" valign="top" colspan="1">
<div class="PlainVisible">
Number
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Range
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
0
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C080–$C08F
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
1
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C090–$C09F
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
2
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C0A0–$C0AF
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
3
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C0B0–$C0BF
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
4
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C0C0–$C0CF
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
5
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C0D0–$C0DF
</div>

</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
6
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$C0E0–$C0EF
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">

</div>
<div class="Indented">
In general, the above addresses need only be accessed with any valid 6502 instruction. However, in the case of reading and writing bytes (last four addresses), care must be taken to insure that the data will be in an appropriate register. All of the following would engage drive number 1. (Assume slot number 6.)
</div>
<pre class="LyX-Code">
<span class="small">        BIT $C0EA</span>
<span class="small">        LDA $C08A,X   (where X-register contains $60)</span>
<span class="small">        CMP $C08A,X   (where X-register contains $60)</span>
</pre>
<div class="Unindented">
Below are typical examples demonstrating the use of the device address assignments. For more examples, see Appendix A. All examples assume that the label SLOT is set to 16 times the desired slot number (e.g. $60 for slot 6).
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.3">6.3</a> Stepper Phase Off Or On
</h2>
<div class="Unindented">
Basically, each of the four phases (0–3) must be turned on and then off again. Done in ascending order moves the arm inward. In descending order, the arm moves outward. For optimum performance, the timing between accesses to these locations is critical, making this a nontrivial exercise. An example is provided in Appendix A demonstrating how to move the arm to a given location.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.4">6.4</a> Motor Off Or On
</h2>
<pre class="LyX-Code">
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C088,X   Turn motor off.</span>
<span class="small"> </span>
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C089,X   Turn motor on (selected drive).</span>
</pre>
<div class="Labeling">
Note: A sufficient delay should be provided to allow the motor time to come up to speed before reading or writing to the disk. Either a specific delay or a routine that watches the data register can be used. See Appendix A for an example.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.5">6.5</a> Engage Drive 1 Or 2
</h2>
<pre class="LyX-Code">
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C08A,X   Engage drive 1.</span>
<span class="small"> </span>
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C08B,X   Engage drive 2.</span>
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-6.6">6.6</a> Read A Byte
</h2>
<pre class="LyX-Code">
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C08E,X   Insure read mode.</span>
<span class="small"> </span>
<span class="small">READ    LDA $C08C,X   Put contents of data register in Accumulator.</span>
<span class="small">        BPL READ      Loop until the high bit is set.</span>
</pre>
<div class="Labeling">
Note: $C08E,X must be accessed to insure Read mode. The loop is necessary to assure that the accumulator will contain valid data. If the data register does not yet contain valid data, the high bit will be zero.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.7">6.7</a> Sense Write Protect
</h2>
<pre class="LyX-Code">
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA $C08D,X   </span>
<span class="small">        LDA $C08E,X   Sense write protect.</span>
<span class="small">        BMI ERROR     If high bit set, protected.</span>
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-6.8">6.8</a> Write Load And Write A Byte
</h2>
<pre class="LyX-Code">
<span class="small">        LDX #SLOT     Put slot number times 16 in X-register.</span>
<span class="small">        LDA DATA      Load accumulator with byte to write.</span>
<span class="small">        STA $C08D,X   Write load.</span>
<span class="small">        STA $C08C,X   Write byte.</span>
</pre>
<div class="Labeling">
Note: $C08F,X must already have been accessed to insure Write mode and a 100-microsecond delay should be invoked before writing.
</div>
<div class="Unindented">
Due to hardware constraints, normal data bytes must be written in 32-cycle loops. The example below writes the two bytes $D5 and $A to the disk. It does this by an immediate load of the accumulator, followed by a subroutine call (WRITE9) that writes the bytes in the accumulator. Timing is so critical that different routines may be necessary, depending on how the data is to be accessed, and code cannot cross memory page boundaries without an adjustment.
</div>
<pre class="LyX-Code">
<span class="small">        LDA #$D5      Load byte to write.     (2 cycles)</span>
<span class="small">        JSR WRITE9    Go write it.            (6)</span>
<span class="small">        LDA #$AA      Load byte to write.     (2)</span>
<span class="small">        JSR WRITE9    Go write it.            (6)</span>
<span class="small">        ...</span>
<span class="small">WRITE9  CLC           Provide different       (2)</span>
<span class="small">WRITE7  PHA           delays to produce       (3)</span>
<span class="small">        PLA           correct timing          (4)</span>
<span class="small">WRITE   STA $C08D,X   Store byte in register. (5)</span>
<span class="small">        ORA $C08C,X   Write byte.             (4)</span>
<span class="small">        RTS           Return to caller.       (6)</span>
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-6.9">6.9</a> Calling A Storage Device Driver
</h2>
<div class="Unindented">
ProDOS is device independent in that it requires a device driver for all storage devices. ProDOS comes with two device drivers built in. One supports the standard Apple floppy disk drive (Disk II or equivalent). The other supports a RAM drive on the Apple IIc or an Apple IIe that has 128K of memory. ProDOS can also support the ProFile hard disk which has its device driver on ROM. It seems clear that there will be many kinds of storage devices available in the future, each with its own driver.
</div>
<div class="Indented">
These device drivers are used as subroutines by the MLI and provide the means of accessing the appropriate device. Four basic functions are currently defined for a device driver. They are <b>STATUS</b>, <b>READ</b>, <b>WRITE</b>, and <b>FORMAT</b>. However, not all device drivers will provide all four functions. The Disk II Device Driver, for example, does not support FORMAT: because of space constraints, this function is provided in the program named FILER.
</div>
<div class="Indented">
The READ BLOCK and WRITE BLOCK calls in the MLI provide the only means of using a device driver from ProDOS and is the preferred method. While it is not generally recommended, any device driver can be called directly. This could prove useful in particular applications that don’t require the MLI. Great care should be taken when calling the device driver directly because doing so can easily destroy data on the particular storage device.
</div>
<div class="Indented">
While the parameters to call a device driver are quite straightforward, there are several potential difficulties to consider. First, RAM based device drivers normally reside in bank-switched memory, and therefore must be carefully selected and deselected. Second, a request for an unsupported device function may produce undesirable results.
</div>
<div class="Indented">
There are four inputs stored in six zero page locations that must contain the appropriate information when a call is made to a device driver. The first input is the <b>Command Code</b>, which indicates which operation is requested. As mentioned earlier, four operations are currently defined. The first of these is STATUS, which is used to determine if the device is ready to be accessed (either Read or Write). Although not all device drivers do so, it is suggested that the number of blocks the device supports be returned, in addition to the status. This should be done using the X (low bytes) and Y (high byte) registers. The remaining operations are quite straightforward — READ for reading a block, WRITE for writing a block, and FORMAT to format or initialize the media.
</div>
<div class="Indented">
The second input value is the <b>Unit Number</b>, indicating in which slot and drive the desired device resides. Only two drives per slot are supported directly, but it is possible to interface a controller card that supports additional drives or volumes.
</div>
<div class="Indented">
The third input is a 2-byte <b>Buffer Pointer</b> that indicates the location of a 512 byte area for data transfer. The MLI verifies that no memory conflicts exist, but most device drivers will not do so; therefore, some degree of care should be exercised in determining this input.
</div>
<div class="Indented">
The fourth input is a 2-byte <b>Block Number</b> indicating which block is to be used for data transfer. The value should be in keeping with the number of blocks available on the desired device.
</div>
<div class="Indented">
The four inputs necessary are listed in Table 6.4.
</div>
<div class="Indented">
Although Apple has defined the manner in which device drivers are to be called, some variations will occur. Even the drivers provided by Apple vary slightly from one another. For this reason, it is advisable to make calls to any device driver with great caution. The parameter list descriptions that follow detail the four kinds of calls that are available. Not all device drivers will support all four call types and a request to an unsupported call type could prove dangerous.
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
Table 6.4 Device Driver Parameters — General Format 
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Location
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Description
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Options
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$42
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Command Code
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$00
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
STATUS
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$01
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
READ
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$02
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
WRITE
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$03
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
FORMAT
</div>

</td>

</tr>

</table>
 
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$43
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Unit Number
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$44–$45
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
I/O Buffer
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Can be $0000 to $FFFF
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$46–$47
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Block Number
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Can be $0000 to $FFFF
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Return Code
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-6.10">6.10</a> Calling the Disk II Device Driver
</h2>
<div class="Unindented">
Access to standard Apple floppy disk drives (Disk II or equivalent) is performed using the Disk II Device Driver provided with ProDOS.
</div>
<div class="Indented">
xxx
</div>
<h3 class="Subsection">
<a class="toc" name="toc-Subsection-6.10.1">6.10.1</a> Device Driver Parameter Lists By Command Code
</h3>
<div class="Unindented">
<div class="center">
$00 STATUS request
</div>

</div>
<div class="ApiList">
<span class="versalitas">Function</span> This call returns the status of a particular device and is generally used to determine if a device is present, and if so, whether it is write protected. Additionally, some drivers will return the number of blocks supported by that device.
</div>
<div class="ApiList">
<span class="versalitas">Required Inputs</span>
</div>
<div class="ApiList">
$42 Must be $00.
</div>
<div class="ApiList">
$43 Unit number of disk to be accessed. The bit assignment of a ProDOS unit number is as follows: DSSS0000 where D is the drive number (0 = drive 1, 1 = drive 2) and SSS is the slot number (1–7).
</div>
<div class="ApiList">
$44–$45 Unused.
</div>
<div class="ApiList">
$46–$47 Unused but sometimes checked for validity (use $0000).
</div>
<div class="ApiList">
<span class="versalitas">Returned Values</span>
</div>
<div class="ApiList">
Carry Flag
</div>
<div class="ApiList">
Clear — No error occurred
</div>
<div class="ApiList">
Set — Error occurred (see Accumulator for type)
</div>
<div class="ApiList">
Accumulator
</div>
<div class="ApiList">
$00 — No error occurred
</div>
<div class="ApiList">
$27 — I/O error or bad block number
</div>
<div class="ApiList">
$28 — No device connected to unit
</div>
<div class="ApiList">
$2B — Disk is write protected
</div>
<div class="ApiList">
X-register Blocks available (low byte).
</div>
<div class="ApiList">
Y-register Blocks available (high byte).
</div>
<div class="Unindented">
<div class="center">
$01 READ request
</div>

</div>
<div class="ApiList">
<span class="versalitas">Function</span> This call <span class="default">will read a 512-byte block and store it at the specified memory location. Most drivers will not check the memory location, so some care is suggested.</span>
</div>
<div class="ApiList">
<span class="versalitas">Required Inputs</span>
</div>
<div class="ApiList">
$42 Must be $01.
</div>
<div class="ApiList">
$43 Unit number of disk to be accessed. The bit assignment of a ProDOS unit number is as follows: DSSS0000 where D is the drive number (0 = drive 1, 1 = drive 2) and SSS is the slot number (1–7).
</div>
<div class="ApiList">
$44–$45 Address (LO/HI) of the caller’s 512-byte buffer into which the block will be read. The buffer need not be page aligned.
</div>
<div class="ApiList">
$46–$47 Block number (LO/HI) to read. Must be valid for the device being called.
</div>
<div class="ApiList">
<span class="versalitas">Returned Values</span>
</div>
<div class="ApiList">
Carry Flag
</div>
<div class="ApiList">
Clear — No error occurred
</div>
<div class="ApiList">
Set — Error occurred (see Accumulator for type)
</div>
<div class="ApiList">
Accumulator
</div>
<div class="ApiList">
$00 — No error occurred
</div>
<div class="ApiList">
$27 — I/O error or bad block number
</div>
<div class="ApiList">
$28 — No device connected to unit
</div>
<pre class="LyX-Code">


</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-7">7</a> Customizing ProDOS
</h1>
<h2 class="Section">
<a class="toc" name="toc-Section-7.1">7.1</a> System Programming With ProDOS
</h2>
<div class="Unindented">
Apple has provided a number of customizing interfaces to ProDOS which allows a programmer to tailor the operation of the system to his specific application needs. These interfaces are considered &ldquo;safe&rdquo; and acceptable when working with ProDOS.
</div>
<div class="Indented">
Before discussing specific system programming considerations, it is important to understand how ProDOS uses memory and what areas are reserved for its use versus those available for applications programs. Referring to Figure 7.1, the following areas of memory are officially &ldquo;owned&rdquo; by the ProDOS Kernel: $D000–$FFFF in the language card (primary $D000–$DFFF bank); $BF00–$BFFF; Zero page locations $3A–$4F; and part of the second 4K bank of the language card (starting at $D100). The rest of this 4K bank is reserved for the QUIT code driver and future uses.The ProDOS Kernel also reserves portions of auxiliary memory (128K) for future use — namely, the same locations it uses in main memory, zero page locations $80–$FF, and locations $200–$3FF. Apple’s future plans for these memory areas include networking and menu managers, so if you use them you do so at your own risk. In a 128K machine, ProDOS currently sets up an electronic &ldquo;RAM drive&rdquo; volume in the auxiliary memory. At present, this volume encompasses most of the auxiliary 64K. In the future, its size may be reduced to accomodate enhancements as mentioned above. You can use auxiliary memory for your own applications if you disable the /RAM device driver (see instructions later in this chapter). If the BASIC Interpreter is used, an additional area of memory from $9600–$BEFF is allocated to its use. $3D0–$3FF is used as a system vector area as defined by the <i>Apple II Reference Manual for the IIe Only</i>.
</div>
<div class="Indented">
Note that ProDOS routines, including the clock driver, make heavy use of $200–$2FF, the monitor GETLN input line buffer. If your programs use this area, you should not depend upon it across ProDOS system calls. You should also be aware of the fact that the MLI cannot be called from memory in the auxiliary bank, and that memory outside the area between $200 and $BEFF in the main RAM bank may not be used for buffers passed to the MLI.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.2">7.2</a> Installing A Program Between The BI And Its Buffers
</h2>
<div class="Unindented">
Once in a while it is useful to find a &ldquo;safe&rdquo; place in memory to put a machine language program (a printer driver, or external command handler, perhaps) where BASIC and ProDOS will never walk over it. If the program is less than 200 bytes long, $300 is a good choice. For larger programs, it is usually better to &ldquo;tuck&rdquo; the program in between the ProDOS BASIC Interpreter and its file I/O buffers. The program need not be relocatable, since the BI will always be in the same place in memory, and the program can be placed at a fixed location just below it (see Figure 5.1). More than one program may be &ldquo;tucked&rdquo; in this area, but this may require one or more of them to be relocated, depending upon the order in which they are loaded.
</div>
<div class="Indented">
To request space for a program, you must execute a call to the BI’s buffer allocation subroutine using a vector in the BI Global Page. You may request a buffer of any size as long as it an even multiple of pages (one page is 256 bytes). When called, the buffer allocation routine relocates any open file buffers as well as its General Purpose Buffer downward in memory, lowering Applesoft’s HIMEM pointer as necessary, and returns the address of the first page in the new buffer. The new buffer will be placed directly below $9600. Subsequent calls to the buffer allocation routine will cause allocations of buffers below earlier ones. the BI file buffers will always be lower in memory than any externally allocated buffers. When you are finished with all of the buffers you have allocated, you may free all of them with a single call. There is no provision for freeing individual buffers
</div>
<div class="Indented">
To allocate a buffer, invoke the following subroutine:
</div>
<pre class="LyX-Code">
<span class="small">GBUFF   LDA #4        ALLOCATE 4 PAGES (1024 BYTES)</span>
<span class="small">        JSR $BEF5     CALL GETBUFR</span>
<span class="small">        BCS ERROR     DID AN ERROR OCCUR?</span>
<span class="small">        STA BUFMSB    STORE BUFFER ADDRESS MSB</span>
<span class="small">        LDA #0</span>
<span class="small">        STA BUFLSB    STORE BUFFER ADDRESS LSB</span>
<span class="small">        RTS           ALL DONE</span>
</pre>
<div class="Unindented">
To free all buffers you have allocated:
</div>
<pre class="LyX-Code">
<span class="small">FBUFFS  JSR $BEF8     CALL FREEBUFR</span>
</pre>
<div class="Unindented">
Note that you may allocate as many buffers as you wish using the GBUFF subroutine, but that a single call to FBUFFS frees all buffers.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.3">7.3</a> Adding Your Own Commands To The ProDOS BASIC Interpreter
</h2>
<div class="Unindented">
There exists a well defined interface to allow you to write your own command handlers for the ProDOS BASIC Interpreter. Suppose, for example, that you wish to add a COPY command which will accept and input pathname, followed by a comma and an output pathname. You can write a handler for such a command in assembly language, install the handler between the BI and its buffers (see the previous section), and then inform the BI of its existence. Every time the BI receives a command line it doesn’t recognize, it will pass it through to your handler before passing it to Applesoft. Note that this implies that your command’s name must be different from any existing ProDOS command name. You may not replace or supercede an existing ProDOS command.
</div>
<div class="Indented">
To install your own command handler, place its entry point address in the vector in the BI Global Page at $BE07 and $BE08. These two bytes are the address portion of a Jump (JMP) instruction (EXTERNCMD) which normally points to a Return from Subroutine (RTS) instruction within the BI. It is not a good idea to assume that this address is pointing to an RTS since someone else’s command handler could have been previously installed. To make sure you do not &ldquo;disconnect&rdquo; an earlier installed command handler and yours is &ldquo;daisy chained&rdquo; to it, save the address you find in EXTERNCMD + 1 and branch to it from your handler if the command line passed is not your command.
</div>
<div class="Indented">
Each time the BI scans a command line and cannot find the command name in its table of valid names, it will call your routine. Your program should compare the command in the command line with yours. The address of the command line is in VPATH1 ($BE6D/$BE6D) in the BI Global Page. The command line consists of a length byte followed by one or mroe ASCII characters with their msot significant bit off. If the command is not yours, jump to the next handler (previous contents of $BE07/$BE08) with the carry set (SEC) to indicate the command is not yours. If the command is yours, there are two options. If the command’s syntax is not compatable with other ProDOS commands (i.e. it has nonstandard operands or keyords), you may immediately begin performing the function indicated. When the program finishes, it should store a zero in PBITS in the BI Global Page ($BE54) to indicate no operands are to be parsed, and return (RTS) with the carry clear (CLC). In this case, do not JMP to the next handler as you would if the command was not yours. If, on the other hand, the command has standard ProDOS syntax, you can use the BI’s syntax scanner to pick off the operands and optional keywords. To do this, once you have identified the command as yours, store the address of the beginning of your code which will process the command (after the syntax scan) in XTERNADDR ($BE50/$BE51) in the BI Global Page, store a $00 in XCNUM ($BE53) to indicate that this is an external command, and store the length of your command name (less one) in XLEN ($BE52) so that the BI will know where to start looking for operands. You should also set up PBITS (two bytes of flags) in the BI Global Page to describe the operands the BI is likely to find on your command. If you have a very simple command with only a pathname as an operand, you can set PBITS ro $01,$00. If you want the BI to automatically provide the prefix of the current volume (default slot, drive) as well as allow the S and D keywords, set PBITS to $01,$04. Once you have set up XTERNADDR, XCNUM, XLEN, and PBITS, return (RTS) to the BI with the carry clear (CLC). When the command line has been successfully scanned, control will return to your handler at the location you indicated in XTERNADDR. If a SYNTAX ERROR occurs, control will not return. When your command handler completes its tasks, it may return to the BI ith an RTS instruction (the carry here is insignificant). Your handler need not save or restore any registers.
</div>
<div class="Indented">
An example of a command handler is given in Appendix A. This program installs a handler between the BI and its buffers, and connscts it to ProDOS through the EXTERNCMD vector. If the ProDOS user enters the command &ldquo;TYPE&rdquo; folloed by a pathname, the command handler reads the indicated file and prints it on the screen.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.4">7.4</a> Disable /RAM Volume For 128K Machines
</h2>
<div class="Unindented">
If your application needs to use the additional 64K in the Extended 80-column Card (or the alternate 64K bank in the IIc) for its on purposes, rather than as an electronic disk drive (RAM drive), you should disable the /RAM device driver. You might want to do this if you plan to use the &ldquo;double HIRES&rdquo; graphics feature of the Apple IIe and IIc, for example.
</div>
<div class="Indented">
The /RAM device driver is installed by the ProDOS Loader/Relocator when the Kernel is loaded. Part of it resides in the Kernel itself (from $FF00–$FF7F), and the remainder remains in auxiliary memory at $200–$3FF. Its address is placed in the list of device drivers for Slot 3, Drive 2 in the System Global Page.
</div>
<div class="Indented">
One way to avoid conflicts between the /RAM and your application is the BSAVE a dummy file such that its blocks will coincide ith the area of memory you ill be using. If you BSAVE an 8K file to /RAM (before any other operations on the /RAM volume), it will fall across $2000–$3FFF, the primary HIRES buffer. If you save a second 8K file it will fall across $4000–$5FFF, the secondary HIRES buffer. This is the easiest way to use &ldquo;double HIRES&rdquo; graphics while leaving the /RAM volume partially available for your use as an electronic disk drive.
</div>
<div class="Indented">
If you want to totally disable the /RAM device driver, you must remove its entry from the System Global Page device driver vector list (DEVADR32). You must lso remove the device number for Slot 3, Drive 2 from the online devices list (DEVLST), and reduce the device count (DEVCNT) by one. If you plan to reinstall the /RAM volume later, be sure to save the contents of DEVADR32 in a safe place so you can later restore it. Note that it is good programming practive to leave /RAM installed upon exiting your programso that other applications may use it. Reinstalling /RAM erases (&ldquo;formats&rdquo;) the volume, so you should not reinstall it upon entry to an application which will be reading files passed via the /RAM volume by a previous application.
</div>
<div class="Indented">
The following subroutine will remove the /RAM driver, allowing alternate uses of the auxilary 64K:
</div>
<pre class="LyX-Code">
<span class="small">        SKP 1</span>
<span class="small">*       START BY CHECKING TO SEE IF /RAM COULD BE THERE</span>
<span class="small">        SKP 1</span>
<span class="small">REMOVE  LDA $BF98       CHECK MACHID</span>
<span class="small">        AND #$30        ISOLATE MEMORY BITS</span>
<span class="small">        CMP #$30        128K?</span>
<span class="small">        BNE NORAM       NO - NO AUX MEMORY</span>
<span class="small">        LDA $BF26</span>
<span class="small">        CMP $BF16       IF SLOT 3, DRV &lt;&gt; DRV 2 VECTOR..</span>
<span class="small">        BNE GOTRAM      THEN IT’S INSTALLED</span>
<span class="small">        LDA $BF27</span>
<span class="small">        CMP $BF17</span>
<span class="small">        BNE GOTRAM</span>
<span class="small">NORAM   SEC ;</span>
<span class="small">OKXIT   RTS</span>
<span class="small">        SKP 1</span>
<span class="small">*       SAVE OLD VECTOR AND REMOVE IT</span>
<span class="small">        SKP 1</span>
<span class="small">GOTRAM  LDA $BF26       SAVE OLD VECTOR CONTENTS</span>
<span class="small">        STA OLDVEC</span>
<span class="small">        LDA $BF27</span>
<span class="small">        STA OLDVEC+1</span>
<span class="small">        LDA $BF16       POINT IT AT "UNISTALLED DEV"</span>
<span class="small">        STA $BF26</span>
<span class="small">        LDA $BF17</span>
<span class="small">        STA $BF27</span>
<span class="small">        SKP 1</span>
<span class="small">*       SQUISH OUT DEVICE NUMBER FROM DEVLST</span>
<span class="small">        SKP 1</span>
<span class="small">        LDX $BF31       GET DEVCNT</span>
<span class="small">DEVLP   LDA $BF32,X     PICK UP LAST DEVICE NUM</span>
<span class="small">        AND #$70        ISOLATE SLOT</span>
<span class="small">        CMP #$30        SLOT = 3?</span>
<span class="small">        BEQ GETSLT      YES, CONTINUE</span>
<span class="small">        DEX</span>
<span class="small">        BPL DEVLP       CONTINUE SEARCH BACKWARDS</span>
<span class="small">        BMI NORAM       CAN’T FIND IT IN DEVLST</span>
<span class="small">GOTSLT  LDA $BF32+1,X   GET NEXT NUMBER</span>
<span class="small">        STA $BF32,X     AND MOVE THEM FORWARD</span>
<span class="small">        INX</span>
<span class="small">        CPX $BF31       REACHED LAST ENTRY?</span>
<span class="small">        BNE GOTSLT      NO, LOOP</span>
<span class="small">        DEC $BF31       REDUCE DEVCNT BY 1</span>
<span class="small">        LDA #$00        ZERO LAST ENTRY IN TABLE</span>
<span class="small">        STA $BF32,X</span>
<span class="small">        CLC</span>
<span class="small">        BCC OKXIT       BRANCH ALWAYS</span>
<span class="small">        SKP 1</span>
<span class="small">OLDVEC  DW  0           OLD VECTOR SAVE AREA</span>
</pre>
<div class="Unindented">
To reinstall the /RAM driver, execute this subroutine:
</div>
<pre class="LyX-Code">
<span class="small">        SKP 1</span>
<span class="small">*       SEE IF SLOT 3 HAS A DRIVER  ALREADY</span>
<span class="small">        SKP 1</span>
<span class="small">HIMEM   EQU $73         PTR TO BI’S GENERAL PURPOSE BUFFER</span>
<span class="small">        SKP 1</span>
<span class="small">INSTALL LDX $BF31       GET DEVCNT</span>
<span class="small">INSLP   LDA $BF32,X     GET A DEVNUM</span>
<span class="small">        AND #$70        ISOLATE SLOT</span>
<span class="small">        CMP #$30        SLOT 3?</span>
<span class="small">        BEQ INSOUT      YES, SKIP IT</span>
<span class="small">        DEX</span>
<span class="small">        BPL INSLP       KEEP UP THE SEARCH</span>
<span class="small">        SKP 1</span>
<span class="small">*       RESTORE THE DEVNUM TO THE LIST</span>
<span class="small">        SKP 1</span>
<span class="small">        LDX $BF31       GET DEVCNT AGAIN</span>
<span class="small">        CPX $0D         DEVICE TABLE FULL</span>
<span class="small">        BNE INSLP2</span>
<span class="small">ERROR   ...             YOUR ERROR ROUTINE</span>
<span class="small">INSLP2  LDA $BF32-1,X   MOVE ALL ENTRIES DOWN</span>
<span class="small">        STA $BF32,X     TO MAKE ROOM AT FRONT</span>
<span class="small">        DEX</span>
<span class="small">        BNE INSLP2</span>
<span class="small">        LDA $#B0</span>
<span class="small">        STA $BF32       SLOT 3, DRIVE 2 AT TOP OF LIST</span>
<span class="small">        INC $BF31       UPDATE DEVCNT</span>
<span class="small">        SKP 1</span>
<span class="small">*       NOW PUT BACK THE DEVICE DRIVER VECTOR</span>
<span class="small">        SKP 1</span>
<span class="small">        LDA OLDVEC</span>
<span class="small">        STA $BF26</span>
<span class="small">        LDA OLDVEC+1</span>
<span class="small">        STA $BF27</span>
<span class="small">        SKP 1</span>
<span class="small">*       FINALLY, REFORMAT THE /RAM VOLUME</span>
<span class="small">        SKP 1</span>
<span class="small">        LDA $BF32</span>
<span class="small">        STA $43         DEVNUM = SLOT 3, DRIVE 2</span>
<span class="small">        LDA #3</span>
<span class="small">        STA $42         CMD = FORMAT</span>
<span class="small">        LDA HIMEM       512-BYTE BLOCK BUFFER</span>
<span class="small">        STA $44         (PAGE ALIGNED)</span>
<span class="small">        LDA HIMEM+1     WE CAN USE BI’S G.P. BUFFER</span>
<span class="small">        STA $45         (IF BI IS AROUND)</span>
<span class="small">        STA $C080       SELECT L.C. FOR DRIVER</span>
<span class="small">        JSR RAMDRV      GO FORMAT THE VOLUME</span>
<span class="small">        STA $C081       SELECT MOTHERBOARD ROMS</span>
<span class="small">INSOUT  RTS ;           AND EXIT TO CALLER</span>
<span class="small">RAMDRV  JMP ($BF26)     &lt;&lt;&lt; JUMP TO /RAM DRIVER &gt;&gt;&gt;</span>
</pre>
<h2 class="Section">
<a class="toc" name="toc-Section-7.5">7.5</a> Writing Your Own Interpreter
</h2>
<div class="Unindented">
A ProDOS &ldquo;Interpreter&rdquo; (also known as a &ldquo;System Program&rdquo;) is a machine language program hich stands between the user and the ProDOS MLI, providing a functions. An interpreter may be executed by the smart RUN command (&ldquo;–&rdquo;), may be invoked at boot time, or may be executed upon leaving another ProDOS interpreter. Interpreters are stored in SYS files on a ProDOS volume, and are initially loaded at $2000, although they may include code to relocate themselves elsewhere once they begin execution. Examples of interpreters are BASIC.SYSTEM (the &ldquo;BI&rdquo;), FILER, CONVERT, and EDASM.SYSTEM. According to convention, an interpreter must be able to pass control to any other interpreter when it exits.
</div>
<div class="Indented">
When writing your own interpreter, you must be aware of these considerations:
</div>
<ol>
<li>
You must BSAVE your interpreter as a &ldquo;SYS&rdquo; type file from location $2000. If you want to include code to execute elsewhere in the machine, you may include a front-end which relocates the rest of the program (this is what the BI does). Normally, the memory available to you in a 64K system includes $800–$BEFF. If you are running in a 48K machine, the ProDOS Kernel occupies memory from $9000–$BFFF so you are limited to $800–$8FFF for your program.
</li>
<li>
If you want your interpreter to be automatically executed as the first interpreter when ProDOS boots, you must name it &ldquo;xxxx.SYSTEM&rdquo;, here xxxx can be any name. It must also be the first SYS file using that naming convention to be found in the Volume Directory of the boot diskette.
</li>
<li>
In order to insure correct operation of the interrupt handler, in the ProDOS Kernel, set the stack register (S) to point to the top of the stack page ($FF) upon entry, and do not use more than the top three quarters of the stack. The interrupt handler assumes that the last item on your stack is stored at $1FF, hen it makes its determination of whether or not to save part of the contents of the stack before invoking an interrupt driver routine.
</li>
<li>
As soon as your program begins execution, it should set up the POWERUP byte in page 3 and three areas in the System Global Page as follows.
</li>

</ol>
<pre class="LyX-Code">
$3F4:   POWERUP byte
$BF58:  BITMAP (system memory bit map)
$BFFC:  IBAKVER (minimum version of MLI acceptable)
$BFFD:  IVERSION (version number of your interpreter)
</pre>
<div class="Unindented">
When your interpreter gets control, it should first set up the RESET vector at $3F2/$3F3 to point to its own RESET handler and fix the POWERUP byte at $3F4 accordingly. The POWERUP byte should be fixed even if you do not replace the RESET handler address (unless you want to reboot on RESET). To fix the POWERUP byte, exclusive OR the contents of $3F3 with #$A5 and store the result in $3F4.
</div>
<div class="Indented">
A subroutine for checking the system memory bit map was given in Chapter 6. Use this to mark those areas in memory which your program will use. Do not mark areas which may be used for MLI buffers. By doing this, the MLI can keep a watchful eye on the execution of your program to prevent accidental overlay of your code with buffers. To determine what values to use for IBAKVER and IVERSION, examine memory in the version of ProDOS you are using for development and note the values at $BFFE (KBAKVER) and $BFFF (KVERSION). Assemble the values you find there as constants into your program, and use these to initialize IBAKVER And IVERSION.
</div>
<ol>
<li>
If you wish to use 80 columns, first check the MACHID byte in the System Global Page to see if 80 columns are available and then call (JSR) $C300. To disable 80-column hardware, load a #$15 into the A register and call $C300. Avoid using the Apple IIe and IIc 80-column soft switches, because these will not work for third party 80-column cards or in an Apple II or Apple II Plus.
</li>
<li>
When your program is ready to exit, close all open files, reinstall the /RAM driver if you disconnected it previously, and execute the following code.
</li>

</ol>
<pre class="LyX-Code">
<span class="small">EXIT    DEC $3F4        FORCE REBOOT ON RESET</span>
<span class="small">        JSR $BF00       CALL THE MLI</span>
<span class="small">        DFB $65         QUIT CALL</span>
<span class="small">        DW  PARMS</span>
<span class="small">        SKP 1</span>
<span class="small">PARMS   DFB 4           4 PARMS</span>
<span class="small">        DFB 0           QUIT TYPE = 0</span>
<span class="small">        DW  0           RESERVED</span>
<span class="small">        DFB 0           RESERVED</span>
<span class="small">        DW  0           RESERVED</span>
</pre>
<div class="Unindented">
The MLI will free any memory you have allocated in the system bit map. It will then prompt the user for a new prefix and pathname for the next interpreter, and will load it and execute it. The code which performs these tasks is at $D100–$D3FF in the secondary 4K block of the language card. It is moved by the MLI to $1000–$12FF before execution. You may create your own quit code by replacing the three pages of code image in the language card if you wish.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.6">7.6</a> Installing New Peripheral Drivers
</h2>
<div class="Unindented">
If you are writing for a peripheral, such as a printer or disk drive, you should be aware of the conventions to which ProDOS adheres when examining and calling drivers.
</div>
<div class="Indented">
If your driver is in ROM on the peripheral card itself, it should follow the Apple II standards for peripherals as follows.
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
For Non-Disk Devices
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Address
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Value
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs05
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$38 (standard BI requirement)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs07
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$18 (standard BI requirement)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs0B
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$01 (generic signature of firmware cards)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs0C
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$ci (specific device signature)
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<div class="Indented">
The device signature is made up of two nibbles. &ldquo;c&rdquo; defines the class of the device as shown below. The second nibble, &ldquo;i&rdquo;, is a specific device identifier assigned by Apple Computer, Inc. 
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top">
&ldquo;c&rdquo; Nibble
</td>
<td align="left" valign="top">
Class
</td>

</tr>
<tr>
<td align="left" valign="top">
$0
</td>
<td align="left" valign="top">
reserved
</td>

</tr>
<tr>
<td align="left" valign="top">
$1
</td>
<td align="left" valign="top">
printer
</td>

</tr>
<tr>
<td align="left" valign="top">
$2
</td>
<td align="left" valign="top">
joystick or X-Y input device
</td>

</tr>
<tr>
<td align="left" valign="top">
$3
</td>
<td align="left" valign="top">
serial or parallel card
</td>

</tr>
<tr>
<td align="left" valign="top">
$4
</td>
<td align="left" valign="top">
modem
</td>

</tr>
<tr>
<td align="left" valign="top">
$5
</td>
<td align="left" valign="top">
sound or speech device
</td>

</tr>
<tr>
<td align="left" valign="top">
$6
</td>
<td align="left" valign="top">
clock
</td>

</tr>
<tr>
<td align="left" valign="top">
$7
</td>
<td align="left" valign="top">
mass storage device
</td>

</tr>
<tr>
<td align="left" valign="top">
$8
</td>
<td align="left" valign="top">
80-column card
</td>

</tr>
<tr>
<td align="left" valign="top">
$9
</td>
<td align="left" valign="top">
network or bus interface
</td>

</tr>
<tr>
<td align="left" valign="top">
$A
</td>
<td align="left" valign="top">
special purpose (other)
</td>

</tr>
<tr>
<td align="left" valign="top">
$B–$F
</td>
<td align="left" valign="top">
reserved
</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<div class="Indented">
ProDOS makes the following special check for a clock:
</div>
<div class="Indented">
<span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top">
Address
</td>
<td align="left" valign="top">
Value
</td>

</tr>
<tr>
<td align="left" valign="top">
$Cs00
</td>
<td align="left" valign="top">
$08 (unique device signature for the Thunderclock)
</td>

</tr>
<tr>
<td align="left" valign="top">
$Cs02
</td>
<td align="left" valign="top">
$28
</td>

</tr>
<tr>
<td align="left" valign="top">
$Cs04
</td>
<td align="left" valign="top">
$58
</td>

</tr>
<tr>
<td align="left" valign="top">
$Cs06
</td>
<td align="left" valign="top">
$70
</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span> span class="align-center"
</div>
<div class="Indented">
<table>
<tr>
<td align="center" valign="top">
For Disk Devices
</td>

</tr>
<tr>
<td align="center" valign="top">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
Address
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Value
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs01
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$20
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(unique disk device signature)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs03
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$00
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs05
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$03
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$Cs07
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$3C
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$CsFC/D
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Disk capacity in blocks (non-DISK II)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$CsFE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Status bits (non-DISK II)
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>1... ....</tt> removable media
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.1.. ....</tt> interruptable device
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..nn ....</tt> number of volumes on device
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.... 1...</tt> format allowed
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.... .1..</tt> write allowed
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.... ..1.</tt> read allowed
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.... ...1</tt> status read allows
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
ProFILE status bits = $47
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$CsFF
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$00 = DISK II
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$xx = LSD of Block device driver in ROM
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
   for non-DISK II ($Csxx
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
   ProFILE hard disk $xx - $EA
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
   $xx may not equal $FF
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>

</table>

</div>
<div class="Indented">
 <span class="unknown">\medskip</span>
</div>
<div class="Indented">
If your device driver is in RAM(below $C000), and you are invoking it using the BASIC Interpreter’s commands PR# A$xxxx or IN# $A$xxxx, the first byte of your code must be a CLD instruction ($D8); otherwise, the BI will not recognize your routine as a valid driver. If your routine is short, you can place it in the $300–$3EF range. If it is longer, you can call the BI’s buffer allocation routine (previously covered in this chapter) to place it between the BI and its buffers.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.7">7.7</a> Installing An Interrupt Handler
</h2>
<div class="Unindented">
If you plan to use a peripheral card which supports interrupts, you may want to write an interrupt handler for that card. You should use the ProDOS first level interrupt handler in the Kernel so that other cards may also service their interrupts. To do this, use theMLI:ALLOC_INTERRUPT call to install your interrupt handler’s entry address in the interrupt vector table within the ProDOS System Global Page. When writing an interrupt handler, follow these steps in the order indicated.
</div>
<ol>
<li>
Make sure your interrupt handler is stored in main memory between $200 and $BEFF.
</li>
<li>
Call the MLI with the ALLOC_INTERRUPT ($40) call to cause your routine’s entry point to be placed in the vector table.
</li>
<li>
Perform whatever I/O is necessary specific to your peripheral to enable its interrupt generating mechanism.
</li>

</ol>
<div class="Unindented">
When your interrupt routine is called, the first instruction executed should be a CLD (to let ProDOS know that this is a valid externally written routine). You should then determine whether the interrupt which caused your routine to be invoked was indeed from your peripheral. If it was not, return to the Kernel with the carry flag set. If it was, service the interrupt, and upon completion, return to the Kernel with the carry flag clear. Your interrupt handler need not save or restore any registers, and it may use up to 16 bytes of stack space and sero page locations $FA through $FF (these are saved and restored by the Kernel). The Kernel assumes that the &ldquo;bottom&rdquo; of the stack is at $1FF when it determines what to save. Your application should always start the stack pointer at $1FF. Note that the motherboard ROM is deactivated in an interrupt hanlder routine (do not attempt to print via $FDED, for example).
</div>
<div class="Indented">
If you wish to remove a previously installed interrupt routine, first disable the interrupt generation mechanism on your peripheral card to prevent further interrupts from occuring, then call the MLI:DEALLOC_INTERRUPT function to remove your handler from the list.
</div>
<div class="Indented">
...
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.8">7.8</a> Creating A New File Type
</h2>
<div class="Unindented">
When you CREATE a file with the MLI, you may specify any file type you wish. If you wish to define a new file type for your application, pick a number between $F1 and $F8. When a CAT or CATALOG command is issued in the BASIC Interpreter, the file type listed will be a &ldquo;$Fn&rdquo;. If you want to use a three letter abbreviation instead, you must modify the table in the BI. The patch given below is highly version dependent and will only work for ProDOS Version 1.0.1 (1 January 1984).
</div>
<div class="Indented">
The first thing to do is examine the table of file types in the BI at $B9DB. This table consists of 14 entries of one byte each, giving the ProDOS file type number for each of the supported types. You will have to replace one of the entries that you never use with your on file type. The entries need not be in numerical order. Immediately following the type table is a table of 3-byte entries giving the names which correspond to the numeric types. This table is in reverse order to the first and begins at $B9E9. As an example, suppose you wished to replace the last entry in the tables, $19 &ldquo;ADB&rdquo;, with $F1 &ldquo;ABC&rdquo;.
</div>
<pre class="LyX-Code">
BLOAD BASIC.SYSTEM,TSYS,A$2000
CALL -151
43E8:F1
43E9:C1 C2 C3
BSAVE BASIC.SYSTEM,TSYS,A$2000
</pre>
<div class="Unindented">
Notice that $B9E8 maps to $43E8 in the unrelocated image of BASIC.SYSTEM.
</div>
<div class="Labeling">
Note: The patches described on this page are for version 1.0.1 of ProDOS and probably will not work with other versions.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-7.9">7.9</a> Recovering Data From A Damaged Disk
</h2>
<div class="Unindented">
If one of the sectors which makes up a block is damaged, ProDOS will return with an I/O error. If in fact the error was in the second half of the block, the first half will be read into memory before the I/O error occurs. However, if the error is in the first half of the block, ProDOS will not attempt to read the second half. To recover the second, undamaged sector of the block, the following patch will force ProDOS to ignore any errors while reading the first half of a block. Errors while reading the second half will still behave normally.
</div>
<pre class="LyX-Code">
BLOAD PRODOS,TSYS,A$2000
CALL -151
5228:00
BSAVE PRODOS,TSYS,A$2000
</pre>
<div class="Unindented">
The above patch, while it will work properly with undamaged blocks, is not advisable in normal use as it will fail to indicate when errors have occurred.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Chapter-8">8</a> ProDOS Global Pages
</h1>
<div class="Unindented">
Readers of <i>Beneath Apple DOS</i> may remember that Chapter 8 of that book was devoted to a detailed analysis of DOS program logic. The contents of that chapter comprised one quarter of the book, and represented a complete description of more than 10K of machine language code. Two factors have led to the approach taken in <i>Beneath Apple ProDOS</i>. First, ProDOS code is expected to be much more volatile than that of DOS. IF material similar to Chapter 8 in <i>Beneath Apple DOS</i> had been published here, it would have quickly become obsolete because of reassemblies of the operating system components by Apple. Throughout its lifetime, DOS as only completely reassembled once — when the change was made from 3.1 to 3.2 in 1979. Our book documented a form of DOS in which most of the instructions had not &ldquo;moved&rdquo; in nearly five years! In contrast, before <i>Beneath Apple ProDOS</i> was published, two different versions of ProDOS were already being distributed — 1.0.1 and 1.0.2. Although the differences between them are very minor, insertions of instructions and data have caused the shifting of major sections of code. Similar changes are expected in the future.
</div>
<div class="Indented">
A second factor in the decision to shorten Chapter 8 involved the physical size of ProDOS. The equivalent components of ProDOS, compared to the DOS code covered in our earlier book, occupy over 22K of memory. A complete treatment of this code ould be a book in and of itself. Coupled with the increased complexity of ProDOS which has resulted in longer chapters overall, as well as the previously mentioned vloatility of the code, we decided that an in-depth coverage of ProDOS program logic did not belong here.
</div>
<div class="Indented">
However, recognizing the importance of this material to many of our readers, a special <b>supplement</b> has been prepared that provides a detailed description of every piece of code and data within the major ProDOS components. It is available directly from Quality Software. Updated editions of this supplement will be available on a periodic basis as Apple releases new versions of ProDOS. In addition, any errata and changes to the main body of <i>Beneath Apple ProDOS</i> will be found in future supplements, eliminating the need to buy future editions of this book. <b>Instructions for ordering the supplement are provided at the end of this chapter</b>.
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.1">8.1</a> BASIC Interpreter Global Page
</h2>
<div class="Unindented">
This page of memory is rigidly defined by the ProDOS BI. Fields given here will not move in later versions of ProDOS and may be referenced by external, user-written programs. Future additions to the global page may be made in areas which are marked &ldquo;Not used&rdquo;.
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;">
Address
</td>
<td align="left" valign="top" style="width: 20%;">
Label
</td>
<td align="left" valign="top" style="width: 50%;">
Contents
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE00–BE02
</td>
<td align="left" valign="top" style="width: 20%;">
BIENTRY
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to WARMDOS (BI warmstart vector).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE03–BE05
</td>
<td align="left" valign="top" style="width: 20%;">
DOSCMD
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to SYNTAX (BI command line parse and execute).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE06–BE08
</td>
<td align="left" valign="top" style="width: 20%;">
EXTRNCMD
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to user-installed external command parser.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE09–BE0B
</td>
<td align="left" valign="top" style="width: 20%;">
ERROUT
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to BI error handler.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE0C–BE0E
</td>
<td align="left" valign="top" style="width: 20%;">
PRINTERR
</td>
<td align="left" valign="top" style="width: 50%;">
JUMP to BI error message print routine. Place error number in A-register.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE0F
</td>
<td align="left" valign="top" style="width: 20%;">
ERRCODE
</td>
<td align="left" valign="top" style="width: 50%;">
ProDOS error code (also at $DE. Applesoft ONERR code).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE10–BE1F
</td>
<td align="left" valign="top" style="width: 20%;">
OUTVEC
</td>
<td align="left" valign="top" style="width: 50%;">
Default output vector in monitor and for each slot (1–7). 
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE20–BE2F
</td>
<td align="left" valign="top" style="width: 20%;">
INVEC
</td>
<td align="left" valign="top" style="width: 50%;">
Default input vector in monitor and for each slot (1–7).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE30–BE31
</td>
<td align="left" valign="top" style="width: 20%;">
VECTOUT
</td>
<td align="left" valign="top" style="width: 50%;">
Current output vector.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE32–BE33
</td>
<td align="left" valign="top" style="width: 20%;">
VECTIN
</td>
<td align="left" valign="top" style="width: 50%;">
Current input vector
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE34–BE35
</td>
<td align="left" valign="top" style="width: 20%;">
VDOSIO
</td>
<td align="left" valign="top" style="width: 50%;">
BI’s output intercept address.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE36–BE37
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
BI’s input intercept address.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE38–BE3B
</td>
<td align="left" valign="top" style="width: 20%;">
VSYSIO
</td>
<td align="left" valign="top" style="width: 50%;">
BI’s internal redirection by STATE.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE3C
</td>
<td align="left" valign="top" style="width: 20%;">
DEFSLT
</td>
<td align="left" valign="top" style="width: 50%;">
Default slot.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE3D
</td>
<td align="left" valign="top" style="width: 20%;">
DEFDRV
</td>
<td align="left" valign="top" style="width: 50%;">
Default drive.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE3E
</td>
<td align="left" valign="top" style="width: 20%;">
PREGA
</td>
<td align="left" valign="top" style="width: 50%;">
A-register save area.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE3F
</td>
<td align="left" valign="top" style="width: 20%;">
PREGX
</td>
<td align="left" valign="top" style="width: 50%;">
X-register save area.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE40
</td>
<td align="left" valign="top" style="width: 20%;">
PREGY
</td>
<td align="left" valign="top" style="width: 50%;">
Y-register save area.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE41
</td>
<td align="left" valign="top" style="width: 20%;">
DTRACE
</td>
<td align="left" valign="top" style="width: 50%;">
Applesoft TRACE is enabled flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE42
</td>
<td align="left" valign="top" style="width: 20%;">
STATE
</td>
<td align="left" valign="top" style="width: 50%;">
Current intercept state. 0 = immediate command mode. &gt; 0 = deferred.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE43
</td>
<td align="left" valign="top" style="width: 20%;">
EXACTV
</td>
<td align="left" valign="top" style="width: 50%;">
EXEC file active flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE44
</td>
<td align="left" valign="top" style="width: 20%;">
IFILACTV
</td>
<td align="left" valign="top" style="width: 50%;">
READ file active flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE45
</td>
<td align="left" valign="top" style="width: 20%;">
OFILACTV
</td>
<td align="left" valign="top" style="width: 50%;">
WRITE file active flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE46
</td>
<td align="left" valign="top" style="width: 20%;">
PFXACTV
</td>
<td align="left" valign="top" style="width: 50%;">
PREFIX read active flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE47
</td>
<td align="left" valign="top" style="width: 20%;">
DIRFLG
</td>
<td align="left" valign="top" style="width: 50%;">
File being READ is a DIR file (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE48
</td>
<td align="left" valign="top" style="width: 20%;">
EDIRFLG
</td>
<td align="left" valign="top" style="width: 50%;">
End of directory flag (no longer used).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE49
</td>
<td align="left" valign="top" style="width: 20%;">
STRINGS
</td>
<td align="left" valign="top" style="width: 50%;">
String space count used to determine when to garbage collect.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4A
</td>
<td align="left" valign="top" style="width: 20%;">
TBUFPTR
</td>
<td align="left" valign="top" style="width: 50%;">
Buffered WRITE data length.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4B
</td>
<td align="left" valign="top" style="width: 20%;">
INPTR
</td>
<td align="left" valign="top" style="width: 50%;">
Command line assembly length.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4C
</td>
<td align="left" valign="top" style="width: 20%;">
CHRLAST
</td>
<td align="left" valign="top" style="width: 50%;">
Previous output character (for recursion check).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4D
</td>
<td align="left" valign="top" style="width: 20%;">
OPENCNT
</td>
<td align="left" valign="top" style="width: 50%;">
Number of files open (not counting EXEC).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4E
</td>
<td align="left" valign="top" style="width: 20%;">
EXFILE
</td>
<td align="left" valign="top" style="width: 50%;">
EXEC file being closed flag (MSB on).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE4F
</td>
<td align="left" valign="top" style="width: 20%;">
CATFLG
</td>
<td align="left" valign="top" style="width: 50%;">
Line type to format next in DIR file READ.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE50–BE51
</td>
<td align="left" valign="top" style="width: 20%;">
XTRNADDR
</td>
<td align="left" valign="top" style="width: 50%;">
External command handler address.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE52
</td>
<td align="left" valign="top" style="width: 20%;">
XLEN
</td>
<td align="left" valign="top" style="width: 50%;">
Length of command name (less one).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE53
</td>
<td align="left" valign="top" style="width: 20%;">
XCNUM
</td>
<td align="left" valign="top" style="width: 50%;">
Number of command:
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$00
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
external
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0A
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
OPEN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$14
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
WRITE
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$01
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
IN#
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0B
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
READ
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$15
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
APPEND
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$02
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
PR#
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0C
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
SAVE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$16
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CREATE
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$03
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CAT
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0D
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BLOAD
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$17
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
DELETE
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$04
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
FRE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0E
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BSAVE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$18
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
PREFIX
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$05
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
RUN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$0F
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CHAIN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$19
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
RENAME
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$06
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
BRUN
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$10
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CLOSE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$1A
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
UNLOCK
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$07
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
EXEC 
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$11
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
FLUSH
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$1B
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
VERIFY
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$08
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
LOAD
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$12
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
NOMON
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$1C
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
CATALOG
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$09
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
SAVE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$13
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
STORE
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$1D
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
RESTORE
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
$1E
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
=
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
POSITION
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE54–BE55
</td>
<td align="left" valign="top" style="width: 20%;">
PBITS
</td>
<td align="left" valign="top" style="width: 50%;">
Permited command operand bits:
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$8000
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Prefix needed. Pathname optiona.l
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$4000
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Slot number only (PR# or IN#).
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$2000
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Deferred command.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$1000
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
File name optional.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0800
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
If file does not exist, create it.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0400
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
T: file type permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0200
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Second file name required.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0100
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
First file name required.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0080
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
AD: address keyword permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0040
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
B: byte offset permitted
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0020
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
E: ending address permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0010
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
L: length permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0008
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
@: line number permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0004
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
S or D: slot/drive permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0002
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
F: field permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
$0001
</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
R: record permitted.
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="center" valign="top">
<div class="PlainVisible">

</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
(V always permitted but ignored).
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE56–BE57
</td>
<td align="left" valign="top" style="width: 20%;">
FBITS
</td>
<td align="left" valign="top" style="width: 50%;">
Operands found on command line. Same bit assignments as above.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE5B–BE59
</td>
<td align="left" valign="top" style="width: 20%;">
VADDR
</td>
<td align="left" valign="top" style="width: 50%;">
A keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE5A–BE5C
</td>
<td align="left" valign="top" style="width: 20%;">
VBYTE
</td>
<td align="left" valign="top" style="width: 50%;">
B keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE5D–BE5E
</td>
<td align="left" valign="top" style="width: 20%;">
VENDA
</td>
<td align="left" valign="top" style="width: 50%;">
E keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE5F-BE60
</td>
<td align="left" valign="top" style="width: 20%;">
VLNTH
</td>
<td align="left" valign="top" style="width: 50%;">
L keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE61
</td>
<td align="left" valign="top" style="width: 20%;">
VSLOT
</td>
<td align="left" valign="top" style="width: 50%;">
S keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE62
</td>
<td align="left" valign="top" style="width: 20%;">
VDRIV
</td>
<td align="left" valign="top" style="width: 50%;">
D keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE63–BE64
</td>
<td align="left" valign="top" style="width: 20%;">
VFELD
</td>
<td align="left" valign="top" style="width: 50%;">
F keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE65–BE66
</td>
<td align="left" valign="top" style="width: 20%;">
VRECD
</td>
<td align="left" valign="top" style="width: 50%;">
R keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE67
</td>
<td align="left" valign="top" style="width: 20%;">
VVOLM
</td>
<td align="left" valign="top" style="width: 50%;">
V keyword value<span class="default"> (ignored)</span>.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE68–BE69
</td>
<td align="left" valign="top" style="width: 20%;">
VLINE
</td>
<td align="left" valign="top" style="width: 50%;">
@ keyword value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE6A
</td>
<td align="left" valign="top" style="width: 20%;">
VTYPE
</td>
<td align="left" valign="top" style="width: 50%;">
T keyword value<span class="default"> (in hex)</span>.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE6B
</td>
<td align="left" valign="top" style="width: 20%;">
VIOSLT
</td>
<td align="left" valign="top" style="width: 50%;">
PR# or IN# slot number value.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE6C–VE6D
</td>
<td align="left" valign="top" style="width: 20%;">
VPATH1
</td>
<td align="left" valign="top" style="width: 50%;">
Primary pathname buffer (Address of length byte).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE6E–BE6F
</td>
<td align="left" valign="top" style="width: 20%;">
VPATH2
</td>
<td align="left" valign="top" style="width: 50%;">
Secondary pathname buffer (Address of length byte).
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE70–BE84
</td>
<td align="left" valign="top" style="width: 20%;">
GOSYSTEM
</td>
<td align="left" valign="top" style="width: 50%;">
Call the MLI using the parameter tables which follow.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE85
</td>
<td align="left" valign="top" style="width: 20%;">
SYSCALL
</td>
<td align="left" valign="top" style="width: 50%;">
MLI call number for this call.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE86–BE87
</td>
<td align="left" valign="top" style="width: 20%;">
SYSPARM
</td>
<td align="left" valign="top" style="width: 50%;">
Address of the MLI parameter list for this call.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE88–BE8A
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Return from MLI call.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE8B–BE9E
</td>
<td align="left" valign="top" style="width: 20%;">
BADCALL
</td>
<td align="left" valign="top" style="width: 50%;">
MLI error return; translate error code to BI error number.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BE9F
</td>
<td align="left" valign="top" style="width: 20%;">
BISPARE1
</td>
<td align="left" valign="top" style="width: 50%;">
Not used.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEA0–BEAB
</td>
<td align="left" valign="top" style="width: 20%;">
SCREATE
</td>
<td align="left" valign="top" style="width: 50%;">
CREATE parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEAC–BEAE
</td>
<td align="left" valign="top" style="width: 20%;">
SSGPRFX
</td>
<td align="left" valign="top" style="width: 50%;">
GET_PREFIX, SET_PREFIX, DESTROY parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEAF–BEB3
</td>
<td align="left" valign="top" style="width: 20%;">
SRENAME
</td>
<td align="left" valign="top" style="width: 50%;">
RENAME parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEB4–BEC5
</td>
<td align="left" valign="top" style="width: 20%;">
SSGINFO
</td>
<td align="left" valign="top" style="width: 50%;">
GET_FILE_INFO, SET_FILE_INFO parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEC6–BECA
</td>
<td align="left" valign="top" style="width: 20%;">
SONLINE
</td>
<td align="left" valign="top" style="width: 50%;">
ONLINE, SET_MARK, GET_MARK, SET_EOF, GET_EOF, SET_BUF, GET_BUF, QUIT parameter list. 
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BECB–BED0
</td>
<td align="left" valign="top" style="width: 20%;">
SOPEN
</td>
<td align="left" valign="top" style="width: 50%;">
OPEN parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BED1–BED4
</td>
<td align="left" valign="top" style="width: 20%;">
SNEWLN
</td>
<td align="left" valign="top" style="width: 50%;">
SET_NEWLINE parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BED5–BEDC
</td>
<td align="left" valign="top" style="width: 20%;">
SREAD
</td>
<td align="left" valign="top" style="width: 50%;">
READ, WRITE parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEDD-BEDE
</td>
<td align="left" valign="top" style="width: 20%;">
SCLOSE
</td>
<td align="left" valign="top" style="width: 50%;">
CLOSE, FLUSH parameter list.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEDF–BEF4
</td>
<td align="left" valign="top" style="width: 20%;">
CCCSPARE
</td>
<td align="left" valign="top" style="width: 50%;">
&ldquo;COPYRIGHT APPLE, 1983&rdquo;
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEF5–BEF7
</td>
<td align="left" valign="top" style="width: 20%;">
GETBUFR
</td>
<td align="left" valign="top" style="width: 50%;">
GETBUFR buffer allocation subroutine vector
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEF8–BEFA
</td>
<td align="left" valign="top" style="width: 20%;">
FREEBUFR
</td>
<td align="left" valign="top" style="width: 50%;">
FREEBUFR buffer free subroutine vector
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEFB
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Original HIMEM MSB
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BEFC–BEFF
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Not used.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span> 
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.2">8.2</a> ProDOS System Global Page — MLI Global Page
</h2>
<div class="Unindented">
Portions of this page of memory are rigidly defined by the MLI and are unlikely to move in later versions of ProDOS. However, some portions are less stable and could change in future releases.
</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="justify" valign="top" style="width: 20%;">
Address
</td>
<td align="justify" valign="top" style="width: 20%;">
Label
</td>
<td align="left" valign="top" style="width: 50%;">
Contents
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;" colspan="3">
<b>Jump Vectors</b>
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF00–BF02
</td>
<td align="justify" valign="top" style="width: 20%;">
ENTRY
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to MLI
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF03–BF05
</td>
<td align="justify" valign="top" style="width: 20%;">
JSPARE
</td>
<td align="left" valign="top" style="width: 50%;">
Jump to system death code (via $BFF6)
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF06–BF08
</td>
<td align="justify" valign="top" style="width: 20%;">
DATETIME
</td>
<td align="left" valign="top" style="width: 50%;">
Jump to Date/Time routine (RTS if no clock).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF09–BF0B
</td>
<td align="justify" valign="top" style="width: 20%;">
SYSERR
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to system error handler.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF0C–BF0E
</td>
<td align="justify" valign="top" style="width: 20%;">
SYSDEATH
</td>
<td align="left" valign="top" style="width: 50%;">
JMP to system death handler.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF0F
</td>
<td align="justify" valign="top" style="width: 20%;">
SERR
</td>
<td align="left" valign="top" style="width: 50%;">
System error number.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="justify" valign="top" style="width: 20%;" colspan="3">
<b>Device Information</b>
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF10–BF11
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR01
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 0 reserved.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF12–BF13
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR11
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 1, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF14–BF15
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR21
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 2, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF16–BF17
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR31
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 3, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF18–BF19
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR41
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 4, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF1A–BF1B
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR51
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 5, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF1C–BF1D
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR61
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 6, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF1E–BF1F
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR71
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 7, drive 1 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF20–BF21
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR02
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 0 reserved.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF22–BF23
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR12
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 1, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF24–BF25
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR22
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 2, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF26–BF27
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR32
</td>
<td align="left" valign="top" style="width: 50%;">
/RAM device driver address (need extra 64K).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF28–BF29
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR42
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 4, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF2A–BF2B
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR52
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 5, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF2C–BF2D
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR62
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 6, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF2E–BF2F
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVADR72
</td>
<td align="left" valign="top" style="width: 50%;">
Slot 7, drive 2 device driver address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF30
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVNUM
</td>
<td align="left" valign="top" style="width: 50%;">
Slot and drive (DSSS0000) of last device.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF31
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVCNT
</td>
<td align="left" valign="top" style="width: 50%;">
Count (minus 1) of active devices.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF32–BF3F
</td>
<td align="justify" valign="top" style="width: 20%;">
DEVLST
</td>
<td align="left" valign="top" style="width: 50%;">
List of active devices (slot, drive and identification — DSSSIIII).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF40–BF4F
</td>
<td align="justify" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Copyright notice.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF50–BF55
</td>
<td align="justify" valign="top" style="width: 20%;">
IRQXITX
</td>
<td align="left" valign="top" style="width: 50%;">
Switch in language card and call IRQ handler at $FFD8.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF56–BF57
</td>
<td align="justify" valign="top" style="width: 20%;">
TEMP
</td>
<td align="left" valign="top" style="width: 50%;">
Temporary storage for IRQ code.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF58–BF6F
</td>
<td align="justify" valign="top" style="width: 20%;">
BITMAP
</td>
<td align="left" valign="top" style="width: 50%;">
Bitmap of low 48K of memory.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF70–BF71
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER1
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 1 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF72–BF73
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER2
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 2 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF74–BF75
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER3
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 3 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF76–BF77
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER4
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 4 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF78–BF79
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER5
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 5 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF7A–BF7B
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER6
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 6 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF7C–BF7D
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER7
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 7 buffer address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF7E–BF7F
</td>
<td align="justify" valign="top" style="width: 20%;">
BUFFER8
</td>
<td align="left" valign="top" style="width: 50%;">
Open file 8 buffer address.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="justify" valign="top" style="width: 20%;" colspan="3">
<b>Interrupt Information</b>
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF80–BF81
</td>
<td align="justify" valign="top" style="width: 20%;">
INTRUPT1
</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt handler address (highest priority).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF82–BF83
</td>
<td align="justify" valign="top" style="width: 20%;">
INTRUPT<span class="default">2</span>
</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt handler address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF84–BF85
</td>
<td align="justify" valign="top" style="width: 20%;">
INTRUPT<span class="default">3</span>
</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt handler address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF86–BF87
</td>
<td align="justify" valign="top" style="width: 20%;">
INTRUPT<span class="default">4</span>
</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt handler address (lowest priority).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF88
</td>
<td align="justify" valign="top" style="width: 20%;">
INTAREG
</td>
<td align="left" valign="top" style="width: 50%;">
A-register save area.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF89
</td>
<td align="justify" valign="top" style="width: 20%;">
INTXREG
</td>
<td align="left" valign="top" style="width: 50%;">
X-register save area.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF8A
</td>
<td align="justify" valign="top" style="width: 20%;">
INTYREG
</td>
<td align="left" valign="top" style="width: 50%;">
Y-register save area.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF8B
</td>
<td align="justify" valign="top" style="width: 20%;">
INT<span class="default">S</span>REG
</td>
<td align="left" valign="top" style="width: 50%;">
S-register save area.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF8C
</td>
<td align="justify" valign="top" style="width: 20%;">
INT<span class="default">P</span>REG
</td>
<td align="left" valign="top" style="width: 50%;">
P-register save area.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF8D
</td>
<td align="justify" valign="top" style="width: 20%;">
INTBANKID
</td>
<td align="left" valign="top" style="width: 50%;">
Bank ID byte (ROM, RAM1, or RAM2).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF8E–BF8F
</td>
<td align="justify" valign="top" style="width: 20%;">
INTADDR
</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt return address.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="justify" valign="top" style="width: 20%;" colspan="3">
<b>General System Information</b>
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF90–BF91
</td>
<td align="justify" valign="top" style="width: 20%;">
DATE
</td>
<td align="left" valign="top" style="width: 50%;">
YYYYYYYM MMMDDDDD.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF92–BF93
</td>
<td align="justify" valign="top" style="width: 20%;">
TIME
</td>
<td align="left" valign="top" style="width: 50%;">
...HHHHH ..MMMMMM.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF94
</td>
<td align="justify" valign="top" style="width: 20%;">
LEVEL
</td>
<td align="left" valign="top" style="width: 50%;">
Current file level.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF95
</td>
<td align="justify" valign="top" style="width: 20%;">
BUBIT
</td>
<td align="left" valign="top" style="width: 50%;">
Backup bit.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF96–BF97
</td>
<td align="justify" valign="top" style="width: 20%;">
SPARE1
</td>
<td align="left" valign="top" style="width: 50%;">
Currently unused.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF98
</td>
<td align="justify" valign="top" style="width: 20%;">
MACHID
</td>
<td align="left" valign="top" style="width: 50%;">
<div class="PlainVisible">
Machine ID Byte.
</div>
<div class="PlainVisible">
<table>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>00..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>0...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
II
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>01..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>0...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
II+
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>10..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>0...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
IIe
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>11..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>0...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
III emulation
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>00..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>1...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Future expansion
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>01..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>1...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Future expansion
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>10..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>1...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
IIc
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>11..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>1...</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Future expansion
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..00</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Unused
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..01</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
48K
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..10</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
64K
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..11</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
128K
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>.X..</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Reserved
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..0.</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
No 80-column card
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>..1.</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
80-column card present
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>...0</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
No compatible clock
</div>

</td>

</tr>
<tr>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>....</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
<tt>...1</tt>
</div>

</td>
<td align="left" valign="top">
<div class="PlainVisible">
Compatible clock present
</div>

</td>

</tr>

</table>

</div>

</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF99
</td>
<td align="justify" valign="top" style="width: 20%;">
SLTBYT
</td>
<td align="left" valign="top" style="width: 50%;">
Slot ROM map (bit on indicates ROM present).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF9A
</td>
<td align="justify" valign="top" style="width: 20%;">
PFIXPTR
</td>
<td align="left" valign="top" style="width: 50%;">
Prefix flag (0 indicates no active prefix).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF9B
</td>
<td align="justify" valign="top" style="width: 20%;">
MLIACTV
</td>
<td align="left" valign="top" style="width: 50%;">
MLI active flag (1... .... indicates active).
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF9C–BF9D
</td>
<td align="justify" valign="top" style="width: 20%;">
CMDADR
</td>
<td align="left" valign="top" style="width: 50%;">
Last MLI call return address.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF9E
</td>
<td align="justify" valign="top" style="width: 20%;">
SAVEX
</td>
<td align="left" valign="top" style="width: 50%;">
X-register save area for MLI calls.
</td>

</tr>
<tr>
<td align="justify" valign="top" style="width: 20%;">
BF9F
</td>
<td align="justify" valign="top" style="width: 20%;">
SAVEY
</td>
<td align="left" valign="top" style="width: 50%;">
Y-register save area for MLI calls.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<b>Language Card Bank Switching Routines</b>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFA0–BFCF
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Language card entry and exit routines.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFA0
</td>
<td align="left" valign="top" style="width: 20%;">
EXIT
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFAA
</td>
<td align="left" valign="top" style="width: 20%;">
EXIT1
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFB5
</td>
<td align="left" valign="top" style="width: 20%;">
EXIT2
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFB7
</td>
<td align="left" valign="top" style="width: 20%;">
MLIENT1
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<b>Interrupt Routines</b>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFD0–BFF3
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Interrupt entry and exit routines.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFD0
</td>
<td align="left" valign="top" style="width: 20%;">
IRQXIT
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFDF
</td>
<td align="left" valign="top" style="width: 20%;">
IRQXIT1
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFE2
</td>
<td align="left" valign="top" style="width: 20%;">
IRQXIT2
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFE7
</td>
<td align="left" valign="top" style="width: 20%;">
ROMXIT
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
  BFEB
</td>
<td align="left" valign="top" style="width: 20%;">
IRQENT
</td>
<td align="left" valign="top" style="width: 50%;">

</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<b>Data</b>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFF4
</td>
<td align="left" valign="top" style="width: 20%;">
BNKBYT1
</td>
<td align="left" valign="top" style="width: 50%;">
Storage for byte at $E000.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFF5
</td>
<td align="left" valign="top" style="width: 20%;">
BNKBYT2
</td>
<td align="left" valign="top" style="width: 50%;">
Storagefor byte at $D000.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFF6–BFFB
</td>
<td align="left" valign="top" style="width: 20%;">

</td>
<td align="left" valign="top" style="width: 50%;">
Switch on language card and call system death handler ($D1E4).
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<div class="Indented">
<table>
<tr>
<td align="left" valign="top" style="width: 20%;" colspan="3">
<b>Version Information</b>
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFFC
</td>
<td align="left" valign="top" style="width: 20%;">
IBAKVER
</td>
<td align="left" valign="top" style="width: 50%;">
Minimum version of Kernel needed for this interpreter.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFFD
</td>
<td align="left" valign="top" style="width: 20%;">
IVERSION
</td>
<td align="left" valign="top" style="width: 50%;">
Version number of this interpreter.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFFE
</td>
<td align="left" valign="top" style="width: 20%;">
KBAKVER
</td>
<td align="left" valign="top" style="width: 50%;">
Minimum version of Kernel compatible with this Kernel.
</td>

</tr>
<tr>
<td align="left" valign="top" style="width: 20%;">
BFFF
</td>
<td align="left" valign="top" style="width: 20%;">
KVERSION
</td>
<td align="left" valign="top" style="width: 50%;">
Version number of this Kernel.
</td>

</tr>

</table>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>
</div>
<h2 class="Section">
<a class="toc" name="toc-Section-8.3">8.3</a> Ordering The Supplement To Beneath Apple ProDOS
</h2>
<div class="Unindented">
Each owner of <i>Beneath Apple ProDOS</i> may order the latest updated supplement. The supplement describes in detail every piece of code and data within the major ProDOS components (see page 8–2). To order the supplement, you must mail the coupon on the next page directly to Quality Software (at the address on the coupon), along with a payment of $10.00 <b>plus</b> shipping and handling charges<span class="FootOuter"><span class="SupFootMarker"> [E] </span><span class="HoverFoot"><span class="SupFootMarker"> [E] </span>Shipping &amp; Handling Charges<table>
<tr>
<td align="left" valign="top">
United States, Canada, and Mexico
</td>
<td align="right" valign="top">
$2.50
</td>

</tr>
<tr>
<td align="left" valign="top">
All other coutries (insured air mail)
</td>
<td align="right" valign="top">
$10.00
</td>

</tr>

</table>
</span></span>. Your payment can be a check or bank draft in US dollars, or your VISA or MasterCard number and expiration date. California residents must add the appropriate sales tax (6 or 6.5%). No phone orders or CODs will be accepted. 
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-A">A</a> Example Programs
</h1>
<pre class="LyX-Code">

</pre>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-B">B</a> Diskette Protection Schemes
</h1>
<div class="Unindented">
Protected software, that software which is modified in some way to prvent it from being copied or duplicated, has existed since very early in the history of the Apple II. This was even true of tape based software before disk drives were widely used. It is not known who protected the first piece of Apple software, but it has become a widespread practive. So has the practice of copying or <b>breaking</b> protected software. It should be pointed out that the following discussion will not take sides in the sometimes controversial subject of software protection. Rather, it will provide an informative look at the methods used to protect software and how those methods bave been circumvented. This seems appropriate since almost all protection schemes now involve a modified or custom disk operating system.
</div>
<div class="Indented">
At this time, ProDOS is still relatively new and it is unclear if it will influence the current practice of protecting software. In that a ProDOS disk is identical to earlier operating systems (DOS 3.3) at a byte level, it is certainly possible and probable that protection will exist. However, since ProDOS can and will support other storage devices (i.e. hard disks etc.), and with the current trend in sharing data between different applications, additional challenges exist for software developers. It is possible that the percentage of protected software may decrease somewhat with the introduction of ProDOS. The following discussion will deal with software protection in general on the Apple II family of computers.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--1"></a>A Brief History Of Apple Software Protection
</h2>
<div class="Unindented">
The first protected software was tape based and appeared in the latter part of 1978, and protected disks followed shortly thereafter. Early protection schemes were often quite effective as there was relatively little technical information available. Almost any modification that rendered the normal means of copying useless was sufficient in most cases — most schemes did in fact consist of relatively minor changes to the normal format of data. Individuals were able to discover and disable these protection methods on a program by program basis, with little or no thought given to some automated means of reproducing protected software.
</div>
<div class="Indented">
It was not until perhaps a year later, in late 1979, that a significant event occurred in disk protection. An extremely popular product was introduced that employed a considerably improved protection method. This marked the beginning of an escalating battle between those protecting software and those trying to copy it. The protection methods used became more and more complex and involved, increasing time and expense for developers to create. The copiers were also increasing their efforts. Programs appeared that were designed to copy particular software products — a major development in that it defeated a great number of different schemes with a single basic technique. These programs are referred to as <b>nibble copiers</b> and were introduced in early 1981.
</div>
<div class="Indented">
Throughout this process, it is clear that both sides made use of the work of their counterparts. Protection schemes stated to reflect a working knowledge of breaking techniques, and were often designed to circumvent a particular method or copier. The people breaking protection methods were also studying the various methods employed to stop them and producing increasingly effective tools. This produced a kind of ebb and flow seen in many competetive areas where each side gains a temporary advantage only to see it lost. Nibble copiers have had numerous revisions to cope with advancements in protection methods.
</div>
<div class="Indented">
Another significant milestone was the introduction of a <b>hardware card</b> that could copy software from the Apple’s memory, thus bypassing most existing protection methods. While it is hard to single out advancements in protection methods, the mere presence of the numerous copy programs, hardware devices, bulletin boards, classes, and magazines aimed at defeating protection methods indicates the constant advancement of protection. Also, the fact that software developers continue to protect software in the face of escalating costs indicates protection is still cost efective.
</div>
<div class="Indented">
The cycle will no doubt continue As new sophisticated schemes are developed, they will be broken by equally sophisticated schemes.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--2"></a>Protection Methods
</h2>
<div class="Unindented">
It seems reasonable at this time to say that it is impossible to protect a program on disk in such a way that it can’t be broken. This is, in large part, due to the nature of the Apple computer and its disk drive. It is an extremely well documented machine, with numerous publications available on both hardware and software functions. It is indeed difficult to hide anything (necessary in protecting software) from anyone who is willing to invest sufficient time to find it.
</div>
<div class="Indented">
Most disk protection methods fall into two different types of schemes. The first involves <b>format alterations</b>, altering some portion of the disk frin its normal format (Chapter 3 and Appendix C provide descriptions of the normal format). The second involves creating an identifiable mark or <b>signature</b> that can be used to verify the disk.
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--1"></a>Format Alteration
</h3>
<div class="Unindented">
A great number of ways exist to alter the format of normal data. They range from a single byte change to an entirely different format. A special case is <b>changing the location</b> of data, and not necessarily the structure of the data itself. n early example of this was moving the directory information from its normal location to a different track altogether. Later, tracks themselves were moved when &ldquo;half&rdquo; tracks becam popular (but data must be a full track apart from other data, a restriction imposed by hardware). Some disks now even use quarter tracks. Although these methods were effective for a while, most nibble copiers are equipped to handle them.
</div>
<div class="Indented">
A more elaborate technique used is known as <b>spiral tracks</b>. Data is staggered on alternating half tracks producing, as its name indicates, a spiral of sorts. Each half track contains approximately one third of a track of data. If the relationship of the different segments is critical, this method of protection can be quite difficult to deal with. Several copy programs are capable of handling this, but may require parameters and additional time to reproduce a disk protected in this manner.
</div>
<div class="Indented">
As with location changes, <b>format changes</b> range from simple to complex. Almost all early changes were merely minor modifications to existing operating systems. The most common change was a change to the code that would read and write the Address Field. This was reasonable because the Address Field is never rewritten, and the only special coderequired was the code to read the modified Address Field.
</div>
<div class="Indented">
The Address Field normally starts with the bytes $D5/$AA/$96. If any of these bytes were changed, a standard operating system would not be able to locate that particular Address Field, causing an error. After the Address Field comes the address information itself (volume, t rack, sector, and checksum). Some common techniques include changing the order of this information, doubling the sector numbers, or altering the checksum with some constant. Any of the above would cause an error on a standard operating system. The Address Field ends with two closing bytes ($DE/$AA), which can be changed or switched also. Similar kinds of changes can be made to the Data Field. These techniques worked well until automated programs appeared.
</div>
<div class="Indented">
The first automated programs were good but generally made the assumption that the data portions had been modified and that the various gaps between the data portions were normal. This prompted modification of the gaps and eventually a radically different format in an attempt to circumvent the copy programs. These formats generally involved either different numbers of otherwise normal sectors on a track, or special sectors with Address and Data Fields combined. As with other advancements, this worked well for a time, but current nibble copiers make as few assumptions about the data format as possible and can generally deal with such techniques. 
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--2"></a>Signature
</h3>
<div class="Unindented">
The earliest example of a signature was probably an unused track (track 3 was commonly &ldquo;un&rdquo;used). The software verifies the signature by trying to read a sector on the unused track. In an error occurred, the signature was verified. As simple as this seems now, it was reasonably effective. While this is a fairly obvious example of a signature, later methods were much more difficult to detect. In fact, most signatures have been uncoveredd by finding and examining the code that verified it. Once a method was known, an algorithm could be developed to deal with it.
</div>
<div class="Indented">
There are three common signatures used currently in protecting disks. The first to appear involves counting the number of bytes on a given track. This is commonly known as <b>nibble counting</b>. The reasoning was that no two drives could spin at precisely the same speed, and therefore would not reproduce a track precisely. While this is in fact true, a number of programs now provide the means to reproduce this type of signature.
</div>
<div class="Indented">
Next to arrive was a method that wsa dependent on the positional relationship between different portions of the disk. This is commonly known as <b>synchronized tracks</b>. It generally involves reading a specific sector, then moving the disk arm to another track (often with nonstandard timing), and finding a particular sector first. The angle between the two sectors is arbitrary, but will always provide just enough time to move the arm and allow for any settling time needed. This relationship between tracks would not normally be maintained when copying the disk, and the signature would thus be removed. This also is provided for in many current copying programs, sometimes requiring parameters for a particular disk. 
</div>
<div class="Indented">
The final method involves writing extra zero bits at given locations on disk. These can be thought of as <b>special sync bytes</b>. When the disk is read, these extra bits are normally discarded. Figure <a class="Reference" href="#fig:B1">B.1↓</a> shows two different bit patterns that produce the same data when read. A special routine looks for the extra bits and thus verifies the signature. There exist some variations to this method which have proved quite difficult for &ldquo;nibble&rdquo; copy programs to handle. Parameters were generally required, but recent advancements in nibble copiers appear to be able to locate and reproduce these extra bits.
</div>
<div class="Indented">
We have dealt primarily with disk protection schemes and nibble copiers, but several other methods of protection exist. These are protection methods which do not allow a program to be taken out of memory and patched to disable the protection scheme. It is worth mentioning that copies produced by a nibble copier are themselves protected, but software broken in some other way may be copied by normal means.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="fig:B1"> </a><div class="figure">
<div class="caption">
Figure B.1 Comparison of a Normal FF Byte and a Special Sync Byte
</div>
<span class="hfill"> </span>11111111 <span class="formula">⟶</span> FF<span class="hfill"> </span>1111111100 <span class="formula">⟶</span> FF<span class="hfill"> </span>
</div>

</div>

</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--3"></a>Memory Protection
</h3>
<div class="Unindented">
It has long been realized that software is vulnerable as it is being loaded into memory, and when it resides entirely in memory. This has prompted a number of techniques, the earliest of which involved <b>reset protection</b>. When the Reset key was pressed (on early Apples), the software could be interrupted and was then resident in memory. Several memory locations were altered during a reset, and many programs were dependent on the values contained in those locations. The later Apple computers provide some measure of protection in that they make it much harder to interrupt software programs. The hardware boards designed to copy software from memory have made memory protection very difficult. The boards generate a Non-Maskable Interrupt and pass control to on-board software. It is not possible to prevent this interrupt form software. About the only defense is simply to never have the entire program in memory at one time. This is often inconvenient but may be the only effective defense. 
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--4"></a>Code Protection
</h3>
<div class="Unindented">
<b>Hiding the code</b> that reads the unusual disk format or checks for a particular signature has become increasingly popular. Early schemes rarely tried to hide anything because there were few people who knew where to look or even what to look for.But it is clear now that most of the advancements in nibble copiers resulted from the examination of the actual code that provided the protection. Signature schemes would have been effective much longer if it had been possible to hide the code that verified them. While it is impossible to prevent the code from being found, it can be made more difficult. The general method used is some sort of encryption of the code. It is decrypted just before execution, and either encrypted again or destroyed just after execution.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--3"></a>The Ideal Protection Scheme
</h2>
<div class="Unindented">
There are thousands of programs available for the Apple II family of machines, and it is safe to say that they have all been copied despite a vast array of protection schemes. It seems reasonable to assume that this fact will not change. Nevertheless, it may be possible to devise a reasonably effective method. It would have to address the three primary ways that software is broken — nibble copiers, hardware boards that copy memory, and what we call the &ldquo;front door&rdquo; method.
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--5"></a>Nibble Copiers
</h3>
<div class="Unindented">
Nibble copy programs have an advantage of sorts in that they need only respond to existng protection methods. This clearly requires considerable skill but not necessarily creativity. In fairness though it should be noted that at least one of the nibble copiers has included capabilities that may effectively deal with yet to be created protection schemes. The best that one should hope for is a protection method that requires parameters to be input by the user of the copier. If the method could be varied so that each variation required a different set of parameters, it would be considered a victory.
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--6"></a>Hardware Boards
</h3>
<div class="Unindented">
It is not possible through software to detect the presence of these boards, not prevent them from saving an image of memory onto a disk. For this reason, they are particularly effective with programs that are totally loaded into memory and require no additional disk accesses. The only good defense is to never have the entire program in memory at one time. While this could create some difficulties such as decreased performance for particular programs, it is nevertheless necessary for single program products. Modular software requiring constant disk access may already provide sufficient protection. 
</div>
<h3 class="Subsection-">
<a class="toc" name="toc-Subsection--7"></a>Front Door Method
</h3>
<div class="Unindented">
The process by which a disk is loaded into memory is well defined for normal disks. Certain facts remain true of protected disks regardless of the method employed. First the disk must contain at least one sector (Track 0, Sector 0) which can be read by the program in the PROM on the disk controller card. Second the code that reads the protected disk must be on the disk. This means that it is possible to trace the boot process by disassembling the code involved in each step of that process. While this can eb a formidable task, it is nevertheless theoretically possible to break all protection schemes with this method. The main defense against use of this method is to make it require a great deal of time to accomplish. This could primarily be done in several ways.
</div>
<div class="Indented">
One way is to write the code in separate modules or layers. Each layer typically decodes the next layer and recodes the previous layer. It is also vital to verify critical layers to ensure thay have not been patched. A second way is to use an interpreted language which introduces an additional level of obscurity and a considerable amount of additional code. Neither of these can be entirely effective, but are important nevertheless.
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-C">C</a> Nibbilizing
</h1>
<div class="Unindented">
This appendix covers in great detail the encoding of data (nibblizing) on the Disk II family of drives (Disk II, IIe, and IIc). Some of this discussion may relate in a general way to encoding techniques on other computers made by Apple. But the details relate specifically to ProDOS and its device driver for a Disk II (or equivalent). 
</div>
<div class="Indented">
Before starting an explanations of encoding, it is fair to ask why data must be encoded at all? It seems reasonable that the data could simply be written to the disk as it is without any encoding. The reason this can’t be done involves the hardware itself. Apple’s design of the original Disk II was innovative and used a unique method of recording the data. While this allowed Apple to produce an excellent product, it did require some additional work to be done in software. It is not possible to read all 256 possible byte values from a diskette. This was clearly not an insurmountable problem, but it did require that the data stored on disk be restricted to bytes with certain characteristics.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--4"></a>Encoding Techniques
</h2>
<div class="Unindented">
Three different techniques have been used. The first one, which is currently used in Address Fields, involves writing a data byte as two <b>disk bytes</b>, one containing the odd bits, and the other containing the even bits. This method is often referred to as &ldquo;<b>4 and 4</b>&rdquo; encoding, depicting the fact that an 8-bit value is split into two 4-bit pieces. It requires two disk bytes for each byte of data, thus 512 disk bytes would be needed for each 256-byte sector of data.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-C.1"> </a><div class="figure">
<div class="caption">
Figure C.1 &ldquo;4 and 4&rdquo; Encoding Technique
</div>
DATA BYTE 
</div>

</div>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-C.2"> </a><div class="figure">
<div class="caption">
Figure C.2 &ldquo;4 and 4&rdquo; Decoding Technique
</div>

</div>

</div>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-C.3"> </a><div class="figure">
<div class="caption">
Figure C.3 Valid 6-Bit Bytes
</div>

</div>

</div>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Figure-C.4"> </a><div class="figure">
<div class="caption">
Figure C.4 &ldquo;6 and 2&rdquo; Write Translation Table
</div>
<table>
<tr>
<td align="center" valign="top">
<tt>00 <span class="formula">⟺</span> 96</tt>
</td>
<td align="center" valign="top">
<tt>40 <span class="formula">⟺</span> B4</tt>
</td>
<td align="center" valign="top">
<tt>80 <span class="formula">⟺</span> D6</tt>
</td>
<td align="center" valign="top">
<tt>C0 <span class="formula">⟺</span> ED</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>04 <span class="formula">⟺</span> 97</tt>
</td>
<td align="center" valign="top">
<tt>44 <span class="formula">⟺</span> B5</tt>
</td>
<td align="center" valign="top">
<tt>84 <span class="formula">⟺</span> D7</tt>
</td>
<td align="center" valign="top">
<tt>C4 <span class="formula">⟺</span> EE</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>08 <span class="formula">⟺</span> 9A</tt>
</td>
<td align="center" valign="top">
<tt>48 <span class="formula">⟺</span> B6</tt>
</td>
<td align="center" valign="top">
<tt>88 <span class="formula">⟺</span> D9</tt>
</td>
<td align="center" valign="top">
<tt>C8 <span class="formula">⟺</span> EF</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>0C <span class="formula">⟺</span> 9B</tt>
</td>
<td align="center" valign="top">
<tt>4C <span class="formula">⟺</span> B7</tt>
</td>
<td align="center" valign="top">
<tt>8C <span class="formula">⟺</span> DA</tt>
</td>
<td align="center" valign="top">
<tt>CC <span class="formula">⟺</span> F2</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>10 <span class="formula">⟺</span> 9D</tt>
</td>
<td align="center" valign="top">
<tt>50 <span class="formula">⟺</span> B9</tt>
</td>
<td align="center" valign="top">
<tt>90 <span class="formula">⟺</span> DB</tt>
</td>
<td align="center" valign="top">
<tt>D0 <span class="formula">⟺</span> F3</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>14 <span class="formula">⟺</span> 9E</tt>
</td>
<td align="center" valign="top">
<tt>54 <span class="formula">⟺</span> BA</tt>
</td>
<td align="center" valign="top">
<tt>94 <span class="formula">⟺</span> DC</tt>
</td>
<td align="center" valign="top">
<tt>D4 <span class="formula">⟺</span> F4</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>18 <span class="formula">⟺</span> 9F</tt>
</td>
<td align="center" valign="top">
<tt>58 <span class="formula">⟺</span> BB</tt>
</td>
<td align="center" valign="top">
<tt>98 <span class="formula">⟺</span> DD</tt>
</td>
<td align="center" valign="top">
<tt>D8 <span class="formula">⟺</span> F5</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>1C <span class="formula">⟺</span> A6</tt>
</td>
<td align="center" valign="top">
<tt>5C <span class="formula">⟺</span> BC</tt>
</td>
<td align="center" valign="top">
<tt>9C <span class="formula">⟺</span> DE</tt>
</td>
<td align="center" valign="top">
<tt>DC <span class="formula">⟺</span> F6</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>20 <span class="formula">⟺</span> A7</tt>
</td>
<td align="center" valign="top">
<tt>60 <span class="formula">⟺</span> BD</tt>
</td>
<td align="center" valign="top">
<tt>A0 <span class="formula">⟺</span> DF</tt>
</td>
<td align="center" valign="top">
<tt>E0 <span class="formula">⟺</span> F7</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>24 <span class="formula">⟺</span> AB</tt>
</td>
<td align="center" valign="top">
<tt>64 <span class="formula">⟺</span> BE</tt>
</td>
<td align="center" valign="top">
<tt>A4 <span class="formula">⟺</span> E5</tt>
</td>
<td align="center" valign="top">
<tt>E4 <span class="formula">⟺</span> F9</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>28 <span class="formula">⟺</span> AC</tt>
</td>
<td align="center" valign="top">
<tt>68 <span class="formula">⟺</span> BF</tt>
</td>
<td align="center" valign="top">
<tt>A8 <span class="formula">⟺</span> E6</tt>
</td>
<td align="center" valign="top">
<tt>EB <span class="formula">⟺</span> FA</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>2C <span class="formula">⟺</span> AD</tt>
</td>
<td align="center" valign="top">
<tt>6C <span class="formula">⟺</span> CB</tt>
</td>
<td align="center" valign="top">
<tt>AC <span class="formula">⟺</span> E7</tt>
</td>
<td align="center" valign="top">
<tt>EC <span class="formula">⟺</span> FB</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>30 <span class="formula">⟺</span> AE</tt>
</td>
<td align="center" valign="top">
<tt>70 <span class="formula">⟺</span> CD</tt>
</td>
<td align="center" valign="top">
<tt>B0 <span class="formula">⟺</span> E9</tt>
</td>
<td align="center" valign="top">
<tt>F0 <span class="formula">⟺</span> FC</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>34 <span class="formula">⟺</span> AF</tt>
</td>
<td align="center" valign="top">
<tt>74 <span class="formula">⟺</span> CE</tt>
</td>
<td align="center" valign="top">
<tt>B4 <span class="formula">⟺</span> EA</tt>
</td>
<td align="center" valign="top">
<tt>F4 <span class="formula">⟺</span> FD</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>38 <span class="formula">⟺</span> B2</tt>
</td>
<td align="center" valign="top">
<tt>78 <span class="formula">⟺</span> CF</tt>
</td>
<td align="center" valign="top">
<tt>B8 <span class="formula">⟺</span> EB</tt>
</td>
<td align="center" valign="top">
<tt>F8 <span class="formula">⟺</span> FE</tt>
</td>

</tr>
<tr>
<td align="center" valign="top">
<tt>3C <span class="formula">⟺</span> B3</tt>
</td>
<td align="center" valign="top">
<tt>7C <span class="formula">⟺</span> D3</tt>
</td>
<td align="center" valign="top">
<tt>BC <span class="formula">⟺</span> EC</tt>
</td>
<td align="center" valign="top">
<tt>FC <span class="formula">⟺</span> FF</tt>
</td>

</tr>

</table>

</div>

</div>

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-D">D</a> The Logic State Sequencer
</h1>
<div class="Unindented">
Because there is such a close relationship between the disk hardware and the software that controls it, it seems appropriate to examine the firmware that directly responds to the software, that is, the Logic State Sequencer ROM. The code on this ROM actually controls the reading and writing of bits. While the information presented here should enable one to understand the process involved, it is nevertheless intended to be an overview and not a complete analysis.
</div>
<div class="Indented">
The Disk II family of drives uses a unique method of storing data on a disk. They use a method named GCR (Group Code Recording) unlike most current disk drives that use FM (Frequency Modulation) or MFM (Modified Frequency Modulation). This enables writing data bytes without the use of clock bits and thereby greatly increases the amount of data that can be stored on a given track. Apple has recently put the Disk Controller Card into a Custom Integrated Circuit. Versions of the Disk Drive Controller Unit (IWM — Integrated Woz/Wendell Machine) are no used on the Apple IIe and the Macintosh. The following discussion is based on the original controller card, but should apply functionally to the new chip as well.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--5"></a>Logic State Sequencer ROM
</h2>
<div class="Unindented">
The Logic State Sequencer is a 256-byte ROM on the disk controller card. The &ldquo;program&rdquo; stored there controls the data register, providing the actual means of reading and writing bits. The program on the ROM is unlike traditional software such as BASIC or machine language — it is a simple language with only six different functions or commands available. What makes it different and difficult to follow is how the flow of the program is determined. Traditional languages typically execute instructions in sequence until they encounter a control statement (such as GOTO or GOSUB) that indicates a new location. In the state machine, each byte is both a command (operating on the data register) and a control statement. What is unique is that the location of the next command is only partially determined by the control statement.
</div>
<div class="Indented">
The program flow is additionally controlled by four external inputs, two provided by software and two provided by hardware. The software inputs are controlled by four memory locations, $C08C through $C08F. The locations are slor dependent (adding the slot number times 16 to the base address gives the appropriate address). Because of the nature of the state machine (timing), this is normally done with the X-register containing the offset (i.e. the slot number times 16). The two inputs provided by the hardware are the presence or absence of a read pulse and the status of the high bit of the data register.
</div>
<div class="Indented">
Each of the 256 bytes in the ROM is an available location that can be accessed with the appropriate control statements. Eight bits are needed to indicate all of the locations. Four of these bits are provided by each byte in the ROM and the remaining four bits are provided by the external inputs described earlier. The four bits in the control statement contained in each byte of the ROM indicate what will be called for the next &ldquo;sequence,&rdquo; and the four bits from the external inputs indicate what will be called for the next &ldquo;state.&rdquo; Figure D.1 depicts the ROM as a two dimensional array, with &ldquo;sequence&rdquo; and &ldquo;state&rdquo; each providing one dimension of the address of a given element. 
</div>
<div class="Indented">
The 16 sequences are simply the hex numbers 0 through F, and are supplied by the high order nibble of each byte in the ROM. The low order nibble is the command number. For example, the byte &ldquo;18&rdquo; would execute command number 8 (no operation) and proceed to sequence 1. Each byte or instruction takes two cycles to execute, but the state machine is running twice as fast as the 6502, so only one 6502 cycle per state machine instruction is required. The six available commands that control the data register are listed in Table D.1.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.1"> </a><div class="table">
<div class="caption">
Table D.1 Commands Which Control The Data Register
</div>
span class="align-center"<table>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top" colspan="2">
Data Register
</td>

</tr>
<tr>
<td align="left" valign="top">
Code
</td>
<td align="left" valign="top">
Operation
</td>
<td align="left" valign="top">
Before
</td>
<td align="left" valign="top">
After
</td>

</tr>
<tr>
<td align="left" valign="top">
0
</td>
<td align="left" valign="top">
Clear
</td>
<td align="left" valign="top">
<tt>XXXXXXXX</tt>
</td>
<td align="left" valign="top">
<tt>00000000</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
8
</td>
<td align="left" valign="top">
No operation
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
9
</td>
<td align="left" valign="top">
Shift left (bringing in a 0)
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>
<td align="left" valign="top">
<tt>BCDEFGH0</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
A
</td>
<td align="left" valign="top">
Shift right (WRITE protected)
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>
<td align="left" valign="top">
<tt>11111111</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top" colspan="1">
(not WRITE protected)
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>
<td align="left" valign="top">
<tt>0ABCDEFG</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
B
</td>
<td align="left" valign="top">
Load
</td>
<td align="left" valign="top">
<tt>XXXXXXXX</tt>
</td>
<td align="left" valign="top">
<tt>YYYYYYYY</tt>
</td>

</tr>
<tr>
<td align="left" valign="top">
D
</td>
<td align="left" valign="top">
Shift left (bringing in a 1)
</td>
<td align="left" valign="top">
<tt>ABCDEFGH</tt>
</td>
<td align="left" valign="top">
<tt>BCDEFGH1</tt>
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
The logic of the state machine is difficult to follow even though relatively few operations are carried out on the data register. Figure D.2 graphically illustrates the logic.
</div>
<div class="Indented">
To make the task easier, the contents of the ROM will be analyzed in four parts, corresponding to the four software states. As mentioned above, the locations $C08C–C08F (plus the slot number times 16) partially controls the state machine. These four locations control two switches, Q6 and Q7. If one of these addresses is accessed, the appropriate switch will be set as indicated in Table D.2.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.2"> </a><div class="table">
<div class="caption">
Table D.2 State Switches
</div>
span class="align-center"<table>
<tr>
<td align="left" valign="top">

</td>
<td align="center" valign="top" colspan="2">
Switch
</td>

</tr>
<tr>
<td align="left" valign="top">
Address
</td>
<td align="center" valign="top">
Q6
</td>
<td align="center" valign="top">
Q7
</td>

</tr>
<tr>
<td align="left" valign="top">
$C08C
</td>
<td align="center" valign="top">
Off
</td>
<td align="center" valign="top">
—
</td>

</tr>
<tr>
<td align="left" valign="top">
$C08D
</td>
<td align="center" valign="top">
On
</td>
<td align="center" valign="top">
—
</td>

</tr>
<tr>
<td align="left" valign="top">
$C08E
</td>
<td align="center" valign="top">
—
</td>
<td align="center" valign="top">
Off
</td>

</tr>
<tr>
<td align="left" valign="top">
$C08F
</td>
<td align="center" valign="top">
—
</td>
<td align="center" valign="top">
On
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
The first state examined will be with switch Q6 on and Q7 off. This can be described as checking the write protect switch and initializing the state machine for writing. Table D.3 lists the contents of this portion of the state machine ROM. All the instructions are identical ($0A), each shifting the data register right (command A), bringin in the status of the write protect sitch, and then going to sequence 0. This readies the hardware for writing since it is necessary to be in sequence 0 in order to write correctly.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.3"> </a><div class="table">
<div class="caption">
Table D.3 State: Q6 On And Q7 Off (Check Write Protect)
</div>
span class="align-center"<table>
<tr>
<td align="center" valign="top">

</td>
<td align="center" valign="top" colspan="2">
High Bit Clear
</td>
<td align="center" valign="top" colspan="2">
High Bit Set
</td>

</tr>
<tr>
<td align="center" valign="top">
Sequence
</td>
<td align="center" valign="top">
Pulse
</td>
<td align="center" valign="top">
No Pulse
</td>
<td align="center" valign="top">
Pulse
</td>
<td align="center" valign="top">
No Pulse
</td>

</tr>
<tr>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
C
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
E
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>
<tr>
<td align="center" valign="top">
F
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>
<td align="center" valign="top">
0A
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
The next state examined is with switches Q6 and Q7 off (see Table D.4). This reads data from the disk, shifting in the appropriate bits as &ldquo;Pulse&rdquo; or &ldquo;No Pulse&rdquo; is detected by the hardware. Additionally, once the high bit of the data register is set, the data is retained until a read pulse is detected (0 bits or &ldquo;No Pulses&rdquo; are ignored).
</div>
<div class="Indented">
When switch Q7 is turned on (write mode), the presence or absence of a read pulse is ignored. For this reason, the ROM contains two identical 64-byte sections. Therefore, Table D.5 is presented in slightly different format. Only two operations are carried out, loading the data register from the data bus, and shifting the data out one bit at time, so that it can be written to the disk. Note that only sequence 2 and A carry out any action on the data register.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.4"> </a><div class="table">
<div class="caption">
Table D.4 State: Q6 Off And Q7 Off (Read)
</div>
span class="align-center"<table>
<tr>
<td align="center" valign="top">

</td>
<td align="center" valign="top" colspan="2">
High Bit Clear
</td>
<td align="center" valign="top" colspan="2">
High Bit Set
</td>

</tr>
<tr>
<td align="center" valign="top">
Sequence
</td>
<td align="center" valign="top">
Pulse
</td>
<td align="center" valign="top">
No Pulse
</td>
<td align="center" valign="top">
Pulse
</td>
<td align="center" valign="top">
No Pulse
</td>

</tr>
<tr>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>

</tr>
<tr>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
2D
</td>
<td align="center" valign="top">
2D
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
38
</td>

</tr>
<tr>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
28
</td>

</tr>
<tr>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
48
</td>

</tr>
<tr>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
58
</td>

</tr>
<tr>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
68
</td>

</tr>
<tr>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
78
</td>

</tr>
<tr>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
88
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
88
</td>

</tr>
<tr>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
98
</td>

</tr>
<tr>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
29
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
A8
</td>

</tr>
<tr>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
CD
</td>
<td align="center" valign="top">
BD
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
B8
</td>

</tr>
<tr>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
D9
</td>
<td align="center" valign="top">
59
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
C8
</td>

</tr>
<tr>
<td align="center" valign="top">
C
</td>
<td align="center" valign="top">
D9
</td>
<td align="center" valign="top">
D9
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
A0
</td>

</tr>
<tr>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
E8
</td>
<td align="center" valign="top">
E8
</td>

</tr>
<tr>
<td align="center" valign="top">
E
</td>
<td align="center" valign="top">
FD
</td>
<td align="center" valign="top">
FD
</td>
<td align="center" valign="top">
F8
</td>
<td align="center" valign="top">
F8
</td>

</tr>
<tr>
<td align="center" valign="top">
F
</td>
<td align="center" valign="top">
DD
</td>
<td align="center" valign="top">
4D
</td>
<td align="center" valign="top">
E0
</td>
<td align="center" valign="top">
E0
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.5"> </a><div class="table">
<div class="caption">
Table D.5 State: Q7 On (Write)
</div>
span class="align-center"<table>
<tr>
<td align="center" valign="top">

</td>
<td align="center" valign="top" colspan="2">
Q6 Off
</td>
<td align="center" valign="top" colspan="2">
Q6 On
</td>

</tr>
<tr>
<td align="center" valign="top">
Sequence
</td>
<td align="center" valign="top">
Clear
</td>
<td align="center" valign="top">
Set
</td>
<td align="center" valign="top">
Clear
</td>
<td align="center" valign="top">
Set
</td>

</tr>
<tr>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
18
</td>

</tr>
<tr>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
28
</td>
<td align="center" valign="top">
28
</td>
<td align="center" valign="top">
28
</td>
<td align="center" valign="top">
28
</td>

</tr>
<tr>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
39
</td>
<td align="center" valign="top">
39
</td>
<td align="center" valign="top">
3B
</td>
<td align="center" valign="top">
3B
</td>

</tr>
<tr>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
48
</td>

</tr>
<tr>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
58
</td>

</tr>
<tr>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
68
</td>

</tr>
<tr>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
78
</td>

</tr>
<tr>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
88
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
88
</td>

</tr>
<tr>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
98
</td>

</tr>
<tr>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
A8
</td>
<td align="center" valign="top">
A8
</td>
<td align="center" valign="top">
A8
</td>
<td align="center" valign="top">
A8
</td>

</tr>
<tr>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
B9
</td>
<td align="center" valign="top">
B9
</td>
<td align="center" valign="top">
BB
</td>
<td align="center" valign="top">
BB
</td>

</tr>
<tr>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
C8
</td>
<td align="center" valign="top">
C8
</td>
<td align="center" valign="top">
C8
</td>
<td align="center" valign="top">
C8
</td>

</tr>
<tr>
<td align="center" valign="top">
C
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
D8
</td>

</tr>
<tr>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
E8
</td>
<td align="center" valign="top">
E8
</td>
<td align="center" valign="top">
E8
</td>
<td align="center" valign="top">
E8
</td>

</tr>
<tr>
<td align="center" valign="top">
E
</td>
<td align="center" valign="top">
F8
</td>
<td align="center" valign="top">
F8
</td>
<td align="center" valign="top">
F8
</td>
<td align="center" valign="top">
F8
</td>

</tr>
<tr>
<td align="center" valign="top">
F
</td>
<td align="center" valign="top">
88
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
88
</td>
<td align="center" valign="top">
08
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
This discussion should provide a general understanding of the Logic State Sequencer. For a comprehensive look at the disk hardware, an excellent source is <i>Understanding the Apple II</i> by Jim Sather, published by Quality Software.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--6"></a>Sequencer Example
</h2>
<div class="Unindented">
Table D.6 follows the state machine through a number of steps during the read process. It is assumed that a $D5 has just been read and is now in the data register. The state machine is executing the instruction at column 4 and sequence 2 of Table D.4 and will continue to loop until a read pulse is detected. The instruction being executed is a $28 which performs a NOP (8 — No OPeration) and remains at sequence 2. In our example, the next byte to read is an $AA (only the first 5 bits are shown in Table D.6). If the reader can understand this example, it should be possible to construct a similar table for any other read or write example. Note that the column number is controlled by the contents of the MSB of the data register and the presence or absence of a Read Pulse.
</div>
<div class="Indented">
<div class="float">
<a class="Label" name="Table-D.6"> </a><div class="table">
<div class="caption">
Table D.6 A Sequence Example
</div>
span class="align-center"<table>
<tr>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
Data
</td>
<td align="center" valign="top">
Read
</td>
<td align="center" valign="top" colspan="3">
Refer To Table D.4
</td>
<td align="center" valign="top">
Next
</td>
<td align="center" valign="top">

</td>

</tr>
<tr>
<td align="left" valign="top">
Step
</td>
<td align="left" valign="top">
Register
</td>
<td align="center" valign="top">
Pulse
</td>
<td align="center" valign="top">
Column
</td>
<td align="center" valign="top">
Sequence
</td>
<td align="center" valign="top">
Byte
</td>
<td align="center" valign="top">
Sequence
</td>
<td align="center" valign="top">
Action*
</td>

</tr>
<tr>
<td align="left" valign="top">
1
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
28
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
2
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
Yes
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
3
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
4
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
5
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
6
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
7
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
8
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
9
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
88
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
10
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No*
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
11
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
A8
</td>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
12
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
B8
</td>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
13
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
C8
</td>
<td align="center" valign="top">
C
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
14
</td>
<td align="left" valign="top">
11010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
C
</td>
<td align="center" valign="top">
A0
</td>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
CLR
</td>

</tr>
<tr>
<td align="left" valign="top">
15
</td>
<td align="left" valign="top">
00000000
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
A
</td>
<td align="center" valign="top">
BD
</td>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
SL1
</td>

</tr>
<tr>
<td align="left" valign="top">
16
</td>
<td align="left" valign="top">
00000001
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
B
</td>
<td align="center" valign="top">
59
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
SL0
</td>

</tr>
<tr>
<td align="left" valign="top">
17
</td>
<td align="left" valign="top">
00000010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
18
</td>
<td align="left" valign="top">
00000010
</td>
<td align="center" valign="top">
Yes
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
19
</td>
<td align="left" valign="top">
00000010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
20
</td>
<td align="left" valign="top">
00000010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
21
</td>
<td align="left" valign="top">
00000010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
2D
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
SL1
</td>

</tr>
<tr>
<td align="left" valign="top">
22
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
23
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
24
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
25
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
26
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No*
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
78
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
27
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
7
</td>
<td align="center" valign="top">
77
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
28
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
8
</td>
<td align="center" valign="top">
98
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
29
</td>
<td align="left" valign="top">
00000101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
9
</td>
<td align="center" valign="top">
29
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
SL0
</td>

</tr>
<tr>
<td align="left" valign="top">
30
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
31
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
48
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
32
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
4
</td>
<td align="center" valign="top">
58
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
33
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
5
</td>
<td align="center" valign="top">
68
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
34
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
Yes
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
6
</td>
<td align="center" valign="top">
D8
</td>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
35
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
D
</td>
<td align="center" valign="top">
08
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
36
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
0
</td>
<td align="center" valign="top">
18
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
NOP
</td>

</tr>
<tr>
<td align="left" valign="top">
37
</td>
<td align="left" valign="top">
00001010
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
1
</td>
<td align="center" valign="top">
2D
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
SL1
</td>

</tr>
<tr>
<td align="left" valign="top">
38
</td>
<td align="left" valign="top">
00010101
</td>
<td align="center" valign="top">
No
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
2
</td>
<td align="center" valign="top">
38
</td>
<td align="center" valign="top">
3
</td>
<td align="center" valign="top">
NOP
</td>

</tr>

</table>

</div>

</div>

</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-E">E</a> ProDOS, DOS, And SOS
</h1>
<div class="Unindented">
This appendix is intended to assist the reader ho si moving programs and data between ProDOS, DOS and SOS operating systems on Apple IIs and Apple IIIs. It is divided into two sections. One deals with the possible problems one might encounter moving from DOS 3.3 or DOS 3.2 to ProDOS with a particular emphasis on the differences in BASIC programming on the two systems. The other section discusses the areas in which ProDOS and SOS are alike, and explains ways in which programs may be written which will run with minimal modifications on either system.
</div>
<h2 class="Section-">
<a class="toc" name="toc-Section--7"></a>Converting from DOS to ProDOS
</h2>
<div class="Unindented">
The following is a list of potential problem areas when converting programs from DOS 3.3 or DOS 3.2 to ProDOS:
</div>
<ol>
<li>
Apple DOS allows 30-character file names with embedded special characters and blanks. ProDOS restricts file names to 15 characters. The first must be a letter, and the rest may be letters, numbers or periods. No blanks or other special characters (other than period) may be in a ProDOS file name.
</li>
<li>
The following DOS commands are not supported by ProDOS: MON, NOMON, MAXFILES, INT, FP, and INIT. MON and NOMON may be entered under ProDOS, but they have no effect.
</li>
<li>
Under ProDOS, the VERIFY command does not read through a file to check it for I/O errors. It only verified the file’s existence.
</li>
<li>
Although the V keyword is syntactically permitted on ProDOS file commands, it is not supported. Programs which depend upon volume numbers must be changed to use volume names instead.
</li>
<li>
When the APPEND command is used on a &ldquo;sparse&rdquo; random file, it will position at the EOF position, not the first &ldquo;hole.&rdquo;
</li>
<li>
CHAINing between BASIC programs is now supported with a command rather than by BRUNing a separate file.
</li>
<li>
The most significant bit of each byte is <b>off</b> in text files under ProDOS. It is <b>on</b> in DOS text files. For example, a blank in DOS was stored as $A0. Under ProDOS, it is stored as $20.
</li>
<li>
Under DOS, many programs use statements of the form: <br>
PRINT CHR$(13);CHR$(4);"dos command to be executed"<br>
This will not work under ProDOS. The CHR$(4) must be the first item in the PRINT list. The CHR$(4) need not be the first thing on an output line, just the first thing in a PRINT statement.
</li>
<li>
DOS supports up to 16 simultaneously open files. ProDOS allows only 8.
</li>
<li>
Less memory is available to BASIC programmers under ProDOS. With no files open, the amount of memory available is equivalent to that available under DOS with three open files. Each open file uses 1024 bytes under ProDOS. Under DOS, only 595 bytes are used per file.
</li>
<li>
HIMEM should always be set to point to an even page boundary under ProDOS (a multiple of 256).
</li>
<li>
ProDOS does not support Integer BASIC programs.
</li>
<li>
The &ldquo;HELLO&rdquo; file name must be &ldquo;STARTUP&rdquo; on ProDOS. DOS allows the user to specify any name for the first file run.
</li>
<li>
All low level assembly language interfaces are drastically different under ProDOS. The MLI must be called to perform disk access wherever the DOS File Manager and RWTS were used in a program. There is no exact equivalent to RWTS in ProDOS, so programs which access the disk by track and sector must be converted to use the READ and WRITE BLOCK MLI calls.
</li>

</ol>
<h2 class="Section-">
<a class="toc" name="toc-Section--8"></a>Writing Programs For ProDOS And SOS
</h2>
<div class="Unindented">
When writing programs which are to run on either ProDOS or SOS, consider the following:
</div>
<ol>
<li>
ProDOS and SOS volumes are identical in format. Either system can read the other’s diskettes.
</li>
<li>
Block 1 on a ProDOS volume contains the SOS boot loader. This program is loaded instead of Block 0 hen booted on an Apple III. It searches the directory for SOS.KERNEL and loads it instead of ProDOS. This means that a diskette can be constructed which will boot on either an Apple II or an Apple III.
</li>
<li>
SOS allows up to 16 concurrently open files in BASIC. ProDOS only allows 8.
</li>
<li>
SOS uses different file types than ProDOS. A ProDOS CATALOG on a SOS diskette will produce hex codes for file type but this is normal. Table E.1 shows all ProDOS and SOS file types currently defined.
</li>
<li>
SOS memory management allows programs to allocate and free segments of memory by making system calls. Under ProDOS, programs must manage memory themselves by marking pages free or in use in the System Global Page.
</li>
<li>
SOS system calls are, for the most part, very similar to ProDOS MLI calls. The areas in which differences occur are: ProDOS filing calls apply only to block devices (disks), but SOS filing calls apply to all devices; GET_FILE_INFO under SOS gives the EOF position of a file, whereas ProDOS’s GET_FILE_INFO does not; SOS’s SET_MARK and SET_EOF positions may be given as relative to the current position, but ProDOS requires them to be absolute.
</li>
<li>
SOS interrupts are prioritized and managed by device drivers; however, ProDOS interrupts are polled sequentially and are managed by interrupt handlers installed using MLI calls.
</li>

</ol>
<div class="Unindented">
<div class="float">
<a class="Label" name="Table-E.1"> </a><div class="table">
<div class="caption">
Table E.1 ProDOS and SOS File Types
</div>
span class="align-center"<table>
<tr>
<td align="left" valign="top">
Hex Type
</td>
<td align="left" valign="top">
ProDOS Name
</td>
<td align="left" valign="top">
OS
</td>
<td align="left" valign="top">
Meaning
</td>

</tr>
<tr>
<td align="left" valign="top">
$00
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
both
</td>
<td align="left" valign="top">
Typeless file
</td>

</tr>
<tr>
<td align="left" valign="top">
$01
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
both
</td>
<td align="left" valign="top">
Bad blocks file
</td>

</tr>
<tr>
<td align="left" valign="top">
$02
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
PASCAL code file
</td>

</tr>
<tr>
<td align="left" valign="top">
$03
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
PASCAL text file
</td>

</tr>
<tr>
<td align="left" valign="top">
$04
</td>
<td align="left" valign="top">
TXT
</td>
<td align="left" valign="top">
both
</td>
<td align="left" valign="top">
ASCII text file
</td>

</tr>
<tr>
<td align="left" valign="top">
$05
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
PASCAL text file
</td>

</tr>
<tr>
<td align="left" valign="top">
$06
</td>
<td align="left" valign="top">
BIN
</td>
<td align="left" valign="top">
both
</td>
<td align="left" valign="top">
Binary File
</td>

</tr>
<tr>
<td align="left" valign="top">
$07
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
Font file
</td>

</tr>
<tr>
<td align="left" valign="top">
$08
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
Graphics screen file
</td>

</tr>
<tr>
<td align="left" valign="top">
$09
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
Business BASIC program file
</td>

</tr>
<tr>
<td align="left" valign="top">
$0A
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
Business BASIC data file
</td>

</tr>
<tr>
<td align="left" valign="top">
$0B
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
Word processor file
</td>

</tr>
<tr>
<td align="left" valign="top">
$0C
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
SOS System file
</td>

</tr>
<tr>
<td align="left" valign="top">
$0D–$0E
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
SOS reserved for future use
</td>

</tr>
<tr>
<td align="left" valign="top">
$0F
</td>
<td align="left" valign="top">
DIR
</td>
<td align="left" valign="top">
both
</td>
<td align="left" valign="top">
Directory file
</td>

</tr>
<tr>
<td align="left" valign="top">
$10
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
RPS data file
</td>

</tr>
<tr>
<td align="left" valign="top">
$11
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
RPS index file
</td>

</tr>
<tr>
<td align="left" valign="top">
$12-$18
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
SOS reserved for future use
</td>

</tr>
<tr>
<td align="left" valign="top">
$19
</td>
<td align="left" valign="top">
ADB
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
AppleWorks data base file
</td>

</tr>
<tr>
<td align="left" valign="top">
$1A
</td>
<td align="left" valign="top">
AWP
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
AppleWorks word processing file
</td>

</tr>
<tr>
<td align="left" valign="top">
$1B
</td>
<td align="left" valign="top">
ASP
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
AppleWorks spreadsheet file
</td>

</tr>
<tr>
<td align="left" valign="top">
$1C-$BF
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
SOS
</td>
<td align="left" valign="top">
SOS reserved for future use
</td>

</tr>
<tr>
<td align="left" valign="top">
$C0-$EE
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
ProDOS reserved for future use
</td>

</tr>
<tr>
<td align="left" valign="top">
$EF
</td>
<td align="left" valign="top">
PAS
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
ProDOS PASCAL file
</td>

</tr>
<tr>
<td align="left" valign="top">
$F0
</td>
<td align="left" valign="top">
CMD
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
Added command file
</td>

</tr>
<tr>
<td align="left" valign="top">
$F1-$F8
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
ProDOS user defined file types
</td>

</tr>
<tr>
<td align="left" valign="top">
$F9
</td>
<td align="left" valign="top">

</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
ProDOS reserved for future use
</td>

</tr>
<tr>
<td align="left" valign="top">
$FA
</td>
<td align="left" valign="top">
INT
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
Integer BASIC program file
</td>

</tr>
<tr>
<td align="left" valign="top">
$FB
</td>
<td align="left" valign="top">
IVR
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
Integer BASIC variables file
</td>

</tr>
<tr>
<td align="left" valign="top">
$FC
</td>
<td align="left" valign="top">
BAS
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
Applesoft BASIC program file
</td>

</tr>
<tr>
<td align="left" valign="top">
$FD
</td>
<td align="left" valign="top">
VAR
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
Applesoft BASIC variables file
</td>

</tr>
<tr>
<td align="left" valign="top">
$FE
</td>
<td align="left" valign="top">
REL
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
EDASM relocatable object module file
</td>

</tr>
<tr>
<td align="left" valign="top">
$FF
</td>
<td align="left" valign="top">
SYS
</td>
<td align="left" valign="top">
ProDOS
</td>
<td align="left" valign="top">
System file
</td>

</tr>

</table>

</div>

</div>

</div>
<div class="Indented">
<span class="unknown">\medskip</span>  
</div>
<h1 class="Chapter">
<a class="toc" name="toc-Appendix-F">F</a> Glossary
</h1>
<div class="Unindented">
<span class="environment"><span class="arrayrow">
<span class="arraycell align-l">
2
</span>

</span>
</span>
</div>
<div class="Description">
<span class="Description-entry">access time.</span> The time required to locate and read or write data on a direct access storage device, such as a diskette drive.
</div>
<div class="Description">
<span class="Description-entry">address.</span> The numeric location of a piece of data in memory, usually given as a hexadecimal number from $0000 to $FFFF (65,535 decimal). A disk address is the location of a data sector expressed in terms of its track and sector numbers.
</div>
<div class="Description">
<span class="Description-entry">algorithm.</span> A sequence of steps which may be performed by a program or other process, which will produce a given result.
</div>
<div class="Description">
<span class="Description-entry">alphanumeric.</span> An alphabetic character (A–Z) or a numeric digit (0–9). In the past, the term referred to the class of all characters and digits.
</div>
<div class="Description">
<span class="Description-entry">analog.</span> Having a value which is continuous, such as a voltage or electrical resistance, as opposed to digital.
</div>
<div class="Description">
<span class="Description-entry">AND.</span> The logical process of determining whether two bits are both &ldquo;1&rdquo;s. 0 AND 1 results in 0 (false). 1 AND 1 results in 1 (true).
</div>
<div class="Description">
<span class="Description-entry">arm.</span> The portion of a disk drive which suspends the read/write head over the disk’s surface. The arm can be moved radially to allow access to different tracks.
</div>
<div class="Description">
<span class="Description-entry">ASCII.</span> American Standard Code for Information Interchange. A hexadecimal to character conversion code assignment, such that the 256 possible values of a single byte may each represent an alphabetic, numeric, special, or control character. ASCII is used when interfacing to peripherals, such as keyboards, printers, or video text displays.
</div>
<div class="Description">
<span class="Description-entry">assembly language.</span> Also known as machine language. The native programming language of the individual computer. Assembly language is oriented to the machine, and is not humanized as is BASIC, PASCAL, or FORTRAN. An assembler is used to convert assembly language statements to an executable program.
</div>
<div class="Description">
<span class="Description-entry">bank switched memory.</span> Also called the language card. An additional 16K of memory which may only be accessed by &ldquo;throwing&rdquo; hardware switches to cause portions of the bank switched memory to temporarily replace the Monitor ROM memory in the machine. This is necessary because an Apple can only address 64K, and all addresses are already used with 48K, 4K of I/O and 12K of Monitor ROM.
</div>
<div class="Description">
<span class="Description-entry">base.</span> The number system in use. Decimal is base 10, since each digit represents a power of 10 (1, 10, 10, \SpecialChar ldots). Hexadecimal is base 16 (1, 16, 256, \SpecialChar ldots). Binary is base 2 (1, 2, 4, 8, \SpecialChar ldots).
</div>
<div class="Description">
<span class="Description-entry">BI.</span> BASIC Interpreter. Also called the BASIC System Program. The BI accepts user commands such as CATALOG and LOAD, and translates them into calls to the ProDOS Machine Language Interface (MLI).
</div>
<div class="Description">
<span class="Description-entry">binary.</span> A number system based upon powers of 2. Only the digits 0 and 1 are used. For example, 101 is binary is 1 units digit, 0 twos, and 1 fours, or 5 in decimal.
</div>
<div class="Description">
<span class="Description-entry">bit cell.</span> The space on a diskette which passes beneath the read/write head in a 4-microsecond interval. A bit cell contains a signal which represents the value of a single binary 0 or 1 (bit).
</div>
<div class="Description">
<span class="Description-entry">bit map.</span> A table where each binary bit represents the allocation of a unit of storage. ProDOS uses bit maps to keep track of memory use (System Bit Map) and of disk use (Volume Bit Map).
</div>
<div class="Description">
<span class="Description-entry">bit slip marks.</span> The epilogue of a disk field, used to double check that the disk head is still in read sync and the sector has not been damaged.
</div>
<div class="Description">
<span class="Description-entry">block.</span> An arbitrary unit of disk space composed of two sectors or 512 bytes. ProDOS reads and writes a block at a time to improve performance and to allow support for larger devices.
</div>
<div class="Description">
<span class="Description-entry">BRK/Break.</span> An assembly language instruction which can be used to force an interrupt and immediate suspension of execution of a program.
</div>
<div class="Description">
<span class="Description-entry">buffer.</span> An area of memory used to temporarily hold data as it is being transferred to or from a peripheral, such as a disk drive.
</div>
<div class="Description">
<span class="Description-entry">carry flag.</span> A 6502 processor flag which indicates that a previous addition resulted in a carry. Also, used as an error indicator by many system programs.
</div>
<div class="Description">
<span class="Description-entry">catalog.</span> A directory of the files on a diskette. See directory.
</div>
<div class="Description">
<span class="Description-entry">chain.</span> A linked list of data elements. Data is chained if its elements need not be contiguous in storage and each element can be found from its predecessor via an address or block pointer.
</div>
<div class="Description">
<span class="Description-entry">checksum/CRC.</span> A method for verifying that data has not been damaged. When data is written, the sum of all its constituent bytes is stored with it. If, when the data is later read, its sum no longer matches the checksum, it has been damaged.
</div>
<div class="Description">
<span class="Description-entry">clobbered.</span> Damaged or destroyed. A clobbered sector is one which has been overwritten such that it is unrecoverable.
</div>
<div class="Description">
<span class="Description-entry">coldstart.</span> A restart of a program which reinitializes all of its parameters, usually erasing any work which was in progress at the the time of the restart.
</div>
<div class="Description">
<span class="Description-entry">contiguous.</span> Physically next to. Two bytes are contiguous if they are adjoining each other in memory or on disk.
</div>
<div class="Description">
<span class="Description-entry">control block.</span> A collection of data which is used by the operating system to manage resources. Examples of control blocks used by ProDOS are the Volume Control Block (VCB) or a Volume Directory Header.
</div>
<div class="Description">
<span class="Description-entry">control character.</span> A special ASCII code which is used to perform a unique function on a peripheral, but does not generate a printable character. Carriage return, line feed, form feed, and a bell are all control characters.
</div>
<div class="Description">
<span class="Description-entry">controller card.</span> A hardware circuit board which is plugged into an Apple connector which allows communication with a peripheral device, such as a disk or printer. A controller card usually contains a small driver program in ROM.
</div>
<div class="Description">
<span class="Description-entry">CSWL.</span> A vector in zero page, through which output data is passed for display on the CRT or for printing.
</div>
<div class="Description">
<span class="Description-entry">cycle.</span> The smallest unit of time within the central processor of the computer. Each machine language instruction requires two or more cycles to complete. One cycle on the Apple is about one microsecond (one millionth of a second).
</div>
<div class="Description">
<span class="Description-entry">data type.</span> The type of information stored in a byte. A byte might contain a printable ASCII character, binary numeric data, or a machine language instruction.
</div>
<div class="Description">
<span class="Description-entry">decimal.</span> A number system based upon powers of 10. digits range from 0 to 9.
</div>
<div class="Description">
<span class="Description-entry">deferred commands.</span> ProDOS commands which may (or must) be invoked from within an executing BASIC program. OPEN, APPEND, READ, WRITE, and CLOSE are all examples of deferred commands.
</div>
<div class="Description">
<span class="Description-entry">digital.</span> Discrete values as opposed to continuous (analog) values. Only digital values may be stored in a computer. Analog measurements from the real world, such as voltage or the level of light outside, must be converted into a numerical value which, of necessity, must be &ldquo;rounded off&rdquo; to a discrete value.
</div>
<div class="Description">
<span class="Description-entry">direct access.</span> Peripheral storage allowing rapid access of any piece of data, regardless of its placement on the medium. Magnetic tape is generally not considered direct access, since the entire tape must be read to locate the last byte. A diskette is considered direct access, since the arm may be rapidly moved to any track and sector.
</div>
<div class="Description">
<span class="Description-entry">directory.</span> A catalog of files stored on a diskette. The directory must contain each file’s name and its location on the disk as well as other information regarding the type of data stored there. In ProDOS, a directory is a file in itself and one directory can describe other subdirectories.
</div>
<div class="Description">
<span class="Description-entry">disk initialization.</span> The process which places track formatting information, including sectors and gaps, on a blank diskette. During diskette initialization, the ProDOS FILER also places a copy of the boot loader in Block 0 and creates an empty Volume Directory in Blocks 2 through 5. The Volume Bit Map is also initialized in Block 6.
</div>
<div class="Description">
<span class="Description-entry">displacement.</span> The distance from the beginning of a block of data to a particular byte or field. Displacements are usually given beginning with 0, for the first byte, 1 for the second, etc. Also known as an offset.
</div>
<div class="Description">
<span class="Description-entry">DOS.</span> Also called DOS 3.2 and DOS 3.3. An earlier disk operating system for the Apple. DOS was designed to support BASIC programming using the Disk II drive only. When hard disks became available, Apple introduced ProDOS.
</div>
<div class="Description">
<span class="Description-entry">driver.</span> A program which provides an input stream to another program or an output device. A printer driver accepts input from a user program in the form of lines to be printed, and sends them to the printer.
</div>
<div class="Description">
<span class="Description-entry">dump.</span> An unformatted or partially formatted listing of the contents of memory or a diskette in hexadecimal. Used for diagnostic purposes.
</div>
<div class="Description">
<span class="Description-entry">encode.</span> To translate data from one form to nother for any of a number of reasons. In ProDOS, data is encoded from 8-bit bytes to 6-bit bytes for storage.
</div>
<div class="Description">
<span class="Description-entry">entry point (EPA).</span> The entry point address is the location within a program where execution is to start. This is not necessarily the same as the load point (or lowest memory address of the program). 
</div>
<div class="Description">
<span class="Description-entry">EOF.</span> End Of File. A 3-byte number ranging from 0 to 16,777,216 (16 megabytes), which represents the offset to the end of the file. If the file is sequential (contains no &ldquo;holes&rdquo;), the EOF is also the length of the file in bytes.
</div>
<div class="Description">
<span class="Description-entry">epilogue.</span> The last three bytes of a field on a track. These unique bytes are used to insure the integrity of the data which precedes them.
</div>
<div class="Description">
<span class="Description-entry">Exclusive OR.</span> A logical operation which compares two bits to determine if they are different. 1 EOR 0 results in 1. 1 EOR 1 results in 0.
</div>
<div class="Description">
<span class="Description-entry">field.</span> A group of contiguous bytes forming a single piece of data, such as a person’s name, his age, or his social security number. In disk formatting, a group of bytes surrounded by gaps.
</div>
<div class="Description">
<span class="Description-entry">file.</span> A named collection of data on a diskette or other mass storage medium. Files can contain data or programs.
</div>
<div class="Description">
<span class="Description-entry">file buffers.</span> In Apple ProDOS, a pair of 512-byte buffers used by the BASIC interpreter to manage one open file. Included are a buffer containing the block image of the current index block and one containing the image of the current data block. File buffers are allocated by the BI as needed by moving Applesoft’s HIMEM pointer down in memory. 
</div>
<div class="Description">
<span class="Description-entry">file descriptive entry.</span> A single entry in a disk directory which describes one file. Included are the name of the file, its data type, its length, its access restrictions, its creation date, its location on the diskette, etc.
</div>
<div class="Description">
<span class="Description-entry">file type.</span> The type of data held by a file. Valid ProDOS file types include Binary (BIN), Applesoft (BAS), Text (TXT), and System (SYS) files. ProDOS supports up to 256 different file types.
</div>
<div class="Description">
<span class="Description-entry">firmware.</span> A middle ground between hardware and software. Usually used to describe micro-code or programs which have been stored in read-only memory (ROM).
</div>
<div class="Description">
<span class="Description-entry">gap.</span> The space between fields of data on a diskette. Gaps on an Apple diskette contain sync bytes.
</div>
<div class="Description">
<span class="Description-entry">garbage collection.</span> The process of combining many small embedded free spaces into one large area. For example, Applesoft performs garbage collection on its string storage to recover memory allocated to strings which have been deleted.
</div>
<div class="Description">
<span class="Description-entry">Global Page.</span> A 256-byte area of memory set aside by ProDOS to contain system variables of general interest. Two Global Pages are currently defined: the System Global Page at $BF00; and the BI Global Page at $BE00. The structure of the Global Pages is rigidly defined, allowing external programs to communicate with ProDOS without depending upon release dependent locations. See also vectors.
</div>
<div class="Description">
<span class="Description-entry">hard error.</span> An unrecoverable Input/Output error. The data stored in the disk sector can never be successfully read again.
</div>
<div class="Description">
<span class="Description-entry">head.</span> The read/write head on a diskette drive. A magnetic pickup, similar in nature to the head on a stereo tapedeck, which rest on the spinning surface of the diskette.
</div>
<div class="Description">
<span class="Description-entry">hexadecimal/HEX.</span> A numeric system based on powers of 16. Valid hex digits range from 0 to 9 and A to F, where A is 10, B is 11, \SpecialChar ldots F is 15. Standard Apple practice is to indicate a number as hexadecimal by preceding it with a dollar sign. $B30 is 11-256s plus 3-16s plus 0-1s, or 2864 in decimal. Two hexadecimal digits can be used to represent the contents of one byte. Hexadecimal is used with computers because it easily converts to binary.
</div>
<div class="Description">
<span class="Description-entry">high memory.</span> The memory locations which have high address values. $FFFF is the highest memory location. Also called the &ldquo;top&rdquo; of memory.
</div>
<div class="Description">
<span class="Description-entry">HIMEM.</span> Applesoft’s zero-page address which identifies the first byte past the available memory which can be used to store BASIC programs and their variables.
</div>
<div class="Description">
<span class="Description-entry">immediate command.</span> A ProDOS command which may be entered at any time, especially when ProDOS is waiting for a command from the keyboard. The opposite of deferred commands.
</div>
<div class="Description">
<span class="Description-entry">index.</span> A displacement into a table or block of storage. 
</div>
<div class="Description">
<span class="Description-entry">index block.</span> A block containing a table of block numbers describing the order and location of the blocks of data within a file. A sapling file has one index block describing up to 256 data blocks. A tree file has a master index block which points to other index blocks, which in turn point to the data blocks in the file.
</div>
<div class="Description">
<span class="Description-entry">instruction.</span> A single step to be performed in an assembly language or machine language program. Instructions perform such operations as addition, subtraction, store, or load. 
</div>
<div class="Description">
<span class="Description-entry">integer.</span> A &ldquo;whole&rdquo; number with no fraction associated with it, as opposed to floating point.
</div>
<div class="Description">
<span class="Description-entry">intercept.</span> A program which logically places itself in the execution path of another program, or pair of programs. A video intercept is sued to redirect program output from the screen to a printer, for example.
</div>
<div class="Description">
<span class="Description-entry">interleave.</span> The practice of selecting the order of sectors on a diskette track to minimize access time due to rotational delay. Also called &ldquo;skewing&rdquo; or interlacing.
</div>
<div class="Description">
<span class="Description-entry">interpreter.</span> A program which translates user written commands or program statements directly into their intended function. Applesoft is an interpreter. The ProDOS BASIC Interpreter translates ProDOS commands into functions such as loading, saving, reading or writing files. Another name for ProDOS interpreters is System Programs.
</div>
<div class="Description">
<span class="Description-entry">interrupt.</span> A hardware signal which causes the computer to halt execution of a program and enter a special handler routine. Interrupts are used to service real-time clock time-outs, BRK instructions, and RESET.
</div>
<div class="Description">
<span class="Description-entry">I/O (Input/Output) error.</span> An error which occurs during transmission of data to or from a peripheral device, such as a disk or cassette tape.
</div>
<div class="Description">
<span class="Description-entry">JMP.</span> A 6502 assembly language instruction which causes the computer to begin executing instructions at a different location in memory. Similar to a GOTO statement in BASIC.
</div>
<div class="Description">
<span class="Description-entry">JSR.</span> A 6502 assembly language instruction which causes the computer to &ldquo;call&rdquo; a subroutine. Similar to a GOSUB statement in BASIC
</div>
<div class="Description">
<span class="Description-entry">K.</span> A unit of measurement, usually applied to bytes. 1 K bytes is equivalent to 1024 bytes.
</div>
<div class="Description">
<span class="Description-entry">Kernel.</span> That part of ProDOS which provides the basic operating system support functions. The Kernel resides in the Language Card or bank switched memory and consists of the MLI, interrupt handler, and diskette and calender/clock device drivers.
</div>
<div class="Description">
<span class="Description-entry">key block.</span> The first block of a ProDOS file.
</div>
<div class="Description">
<span class="Description-entry">KSWL.</span> A vector in zero page through which input data is passed from the keyboard or a remote terminal.
</div>
<div class="Description">
<span class="Description-entry">label.</span> A name associated with a location in a program or in memory. Labels are used in assembly language much like statement numbers are used in BASIC. 
</div>
<div class="Description">
<span class="Description-entry">language card.</span> An additional 16K of RAM added to an Apple II or Apple II Plus using a card in slot 0. The card gets its name from its original use with the Apple UCSD PASCAL system and for loading other versions of BASIC. Apple IIe’s have this additional memory built in. See also bank switched memory.
</div>
<div class="Description">
<span class="Description-entry">latch.</span> A component into which the Input/Output hardware can store a byte value, which will hold that value until the central processor has time to read it (or vice versa).
</div>
<div class="Description">
<span class="Description-entry">link.</span> An address or block pointer in an element of a linked chain of data or buffers.
</div>
<div class="Description">
<span class="Description-entry">list.</span> A one dimensional sequential array of data items.
</div>
<div class="Description">
<span class="Description-entry">load point (LP).</span> The lowest address of a loaded assembly language program — the first byte loaded. Not necessarily the same as the entry point address (EPA).
</div>
<div class="Description">
<span class="Description-entry">locked.</span> A file is locked if it is restricted from certain types of access — usually one which is read only. ProDOS provides control over file access through the use of directory entry bits.
</div>
<div class="Description">
<span class="Description-entry">logical.</span> A form of arithmetic which separates with binary &ldquo;truth&rdquo; or &ldquo;false&rdquo;, 1 or 0. AND, OR, NAND, NOT, and Exclusive OR are all logical operations.
</div>
<div class="Description">
<span class="Description-entry">LOMEM.</span> Applesoft’s zero-page address which identifies the first byte of available memory which can be used to store BASIC programs and their variables.
</div>
<div class="Description">
<span class="Description-entry">loop.</span> A programming construction in which a group of instructions or statements are repeatedly executed.
</div>
<div class="Description">
<span class="Description-entry">low memory.</span> The memory locations with the lowest addresses. $0000 is the lowest memory location. Also called the &ldquo;bottom&rdquo; of memory.
</div>
<div class="Description">
<span class="Description-entry">LSB/Lo order.</span> Least Significant Bit or Least Significant Byte. The 1s bit in a byte or the second pair of hexadecimal digits forming an address. In the address $8030, $30 is the Lo order part of the address.
</div>
<div class="Description">
<span class="Description-entry">mark.</span> A 3-byte &ldquo;byte number&rdquo; or position within a ProDOS file. When a file is being read by the MLI, a current mark is maintained as well as the EOF mark. See also EOF.
</div>
<div class="Description">
<span class="Description-entry">microsecond.</span> A millionth of a second. Equivalent to one cycle of the Apple II central processor. Also written as &ldquo;<span class="formula"><i>μ</i></span>sec&rdquo;
</div>
<div class="Description">
<span class="Description-entry">MLI.</span> Machine Language Interface. The MLI is part of the ProDOS Kernel which resides in the language card or bank switched memory. The MLI performs such functions as OPENing a file, WRITING to a file, or DESTROYing a file.
</div>
<div class="Description">
<span class="Description-entry">monitor.</span> A machine language program which always resides in the computer and which is the first to receive control when the machine is powered up. The apple monitor resides in ROM and allows examination and modification of memory at a byte level.
</div>
<div class="Description">
<span class="Description-entry">MSB/Hi order.</span> Most Significant Bit or Most Significant Byte. The 128’s bit of a byte (the left-most) or the first pair of a hexadecimal address. In the byte value $83, the MSB is on (is a 1).
</div>
<div class="Description">
<span class="Description-entry">nibble/nybble.</span> A portion of a byte, usually 4 bits and represented by a single hexadecimal digit. $FE contains to nibbles, $F and $E.
</div>
<div class="Description">
<span class="Description-entry">null.</span> Empty, having no length or value. A null string is one which contains no characters. The null control character ($00) produces no effect on a printer (also called an idle).
</div>
<div class="Description">
<span class="Description-entry">object code.</span> A machine language program in binary form, ready to execute. Object code is the output of an assembler.
</div>
<div class="Description">
<span class="Description-entry">object module.</span> A complete machine language program code in object code form, stored as a file on a diskette.
</div>
<div class="Description">
<span class="Description-entry">offset.</span> The distance from the beginning of a block of data to a particular byte or field. Offsets are usually given beginning with 0, for the first byte, 1 for the second, etc. Also known as a displacement.
</div>
<div class="Description">
<span class="Description-entry">opcode, operation code.</span> The three letter mnemonic representing a single assembly language instruction. JMP is the opcode for the jump instruction.
</div>
<div class="Description">
<span class="Description-entry">operating system.</span> A machine language program which manages the memory and peripherals automatically, simplifying the job of the applications programmer.
</div>
<div class="Description">
<span class="Description-entry">OR.</span> The logical operation comparing two bits to determine if either of them are 1. 1 OR 1 results in 1 (true). 1 OR 0 results in 1, 0 OR 0 results in 0 (false).
</div>
<div class="Description">
<span class="Description-entry">overhead.</span> The space required by the system, either in memory or on the disk, to manage either. The boot blocks, Volume Directory, and Volume Bit Map are part of a diskette’s overhead.
</div>
<div class="Description">
<span class="Description-entry">page.</span> 256 bytes od memory which share a common high order address byte. Zero page is the first 256 bytes of memory ($0000 through $00FF).
</div>
<div class="Description">
<span class="Description-entry">parallel.</span> A communication mode which sends all bits in a byte at once, each over a separate line or wire. Opposite of serial.
</div>
<div class="Description">
<span class="Description-entry">parameter list.</span> An area of storage set aside for communication between a calling program and a subroutine. The parameter list contains input and output variables which will be used by the subroutine.
</div>
<div class="Description">
<span class="Description-entry">parity.</span> A scheme which allows detection of errors in a single data byte, similar to checksums but on a bit level rather than a byte level. An extra parity bit is attached to each byte which is a sum of the bits in the byte. Parity is used to detect or correct single bit failures, and when sending data over communication lines to detect noise errors.
</div>
<div class="Description">
<span class="Description-entry">parse.</span> The process of interpreting character string data, such as a command with keywords.
</div>
<div class="Description">
<span class="Description-entry">patch.</span> A small change to the object code of an assembly language program. Also called a &ldquo;zap&rdquo;.
</div>
<div class="Description">
<span class="Description-entry">pathname.</span> A string describing the path ProDOS must follow to find a file. A fully qualified pathname consists of the volume name followed by one or more directory names followed by the name of the file itself. If a partial pathname is given, a default prefix is attached to it to form a complete pathname. See also prefix.
</div>
<div class="Description">
<span class="Description-entry">physical record.</span> A collection of data corresponding to the smallest unit of storage on a peripheral device. For disks, a physical record is a sector.
</div>
<div class="Description">
<span class="Description-entry">pointer.</span> The address or memory location of a block of data or a single data item. The address &ldquo;points&rdquo; to the data. A pointer may also be a block number, such as the pointer to the Volume Bit Map in the Volume Directory Header.
</div>
<div class="Description">
<span class="Description-entry">prefix.</span> A system maintained default character string which is automatically attached to file names entered by the user to form a complete pathname. See also pathname.
</div>
<div class="Description">
<span class="Description-entry">prologue.</span> The three bytes at the beginning of a disk field which uniquely identify it from any other data on the track.
</div>
<div class="Description">
<span class="Description-entry">PROM.</span> Programmable Read Only Memory. PROMs are usually used on controller cards associated with peripherals to hold the driver program which interfaces the device to applications programs.
</div>
<div class="Description">
<span class="Description-entry">prompt.</span> An output string which lets the user know that input is expected. An &ldquo;*&rdquo; is the prompt character fot the Apple monitor.
</div>
<div class="Description">
<span class="Description-entry">pseudo-opcode.</span> A special assembly language opcode which does not translate into a machine instruction. A pseudo-opcode instructs the assembler to perform some function, such as skipping a page in an assembly listing or reserving data space in the output object code.
</div>
<div class="Description">
<span class="Description-entry">RAM.</span> Random Access Memory. Computer memory which will allow storage and retrieval of values by address.
</div>
<div class="Description">
<span class="Description-entry">random access.</span> Direct access. The capability to rapidly access any single piece of data on a storage medium without having to sequentially read all of its predecessors.
</div>
<div class="Description">
<span class="Description-entry">recal.</span> Recalibrate the disk arm so that the read/write head is positioned over track zero. This is done by pulling the arm as far as it will go to the outside of the diskette until it hits a stop, producing a &ldquo;clacking&rdquo; sound.
</div>
<div class="Description">
<span class="Description-entry">reference number (REF NUM).</span> An arbitrary number assigned to an open file by the MLI to simplify identification in later calls.
</div>
<div class="Description">
<span class="Description-entry">register.</span> A named temporary storage location in the central processor itself. The 6502 has 5 registers: the A, X, Y, S, and P registers. Registers are used by an assembly language program to access memory and perform arithmetic.
</div>
<div class="Description">
<span class="Description-entry">relocatable.</span> The attribute of an object module file which contains a machine language program and the information necessary to make it run at any memory locations.
</div>
<div class="Description">
<span class="Description-entry">return code.</span> A numeric value returned from a subroutine, indicating the success or failure of the operation attempted. A return code of zero usually means there were no errors. Any other value indicates the nature of the error, as defined by the design of the subroutine.
</div>
<div class="Description">
<span class="Description-entry">ROM.</span> Read Only Memory. Memory which has a permanent value. The Apple monitor and Applesoft BASIC are stored in ROM.
</div>
<div class="Description">
<span class="Description-entry">sapling.</span> A ProDOS file which requires only one index block (2 to 256 data blocks). A sapling ranges from 513 bytes to 131,072 bytes in length. See also seedling and tree.
</div>
<div class="Description">
<span class="Description-entry">search.</span> The process of scanning a track for a given sector.
</div>
<div class="Description">
<span class="Description-entry">sector.</span> The smallest updatable unit of data on a disk track. One sector on an Apple Disk II contains 256 data bytes.
</div>
<div class="Description">
<span class="Description-entry">sector address.</span> A disk field which identifies the following sector data field in terms of its volume, track, and sector number. 
</div>
<div class="Description">
<span class="Description-entry">sector data.</span> A disk field which contains the actual sector data in nibbilized form.
</div>
<div class="Description">
<span class="Description-entry">seedling.</span> A ProDOS file which has only a single data block (512 bytes). A seedling file does not require index blocks. See also sapling and tree.
</div>
<div class="Description">
<span class="Description-entry">seek.</span> The process of moving the disk arm to a given track.
</div>
<div class="Description">
<span class="Description-entry">self-sync.</span> Also called &ldquo;auto-sync&rdquo; bytes. Special disk bytes which contain more than 8 bits, allowing synchronization of the hardware to byte boundaries when reading.
</div>
<div class="Description">
<span class="Description-entry">sequential access.</span> A mode of data retrieval where each byte of data is read in the order in which it was written to the disk.
</div>
<div class="Description">
<span class="Description-entry">serial.</span> A communication mode which sends data bits one at a time over a single line or wire. As opposed to parallel.
</div>
<div class="Description">
<span class="Description-entry">shift.</span> A logical operation which moves the bits of a byte either left or right one position, moving a 0 into the bit at the other end.
</div>
<div class="Description">
<span class="Description-entry">skewing.</span> The process of interleaving sectors. See interleave.
</div>
<div class="Description">
<span class="Description-entry">soft error.</span> A recoverable I/O error. A worn diskette might produce soft errors occasionally.
</div>
<div class="Description">
<span class="Description-entry">SOS.</span> Sophisticated Operating System. The standard operating system for the Apple III computer.
</div>
<div class="Description">
<span class="Description-entry">source code.</span> A program in a form which is understandable to humans; in a character form as opposed to internal binary machine format. Source assembly code must be processed by an assembler to translate it into machine or &ldquo;object&rdquo; code.
</div>
<div class="Description">
<span class="Description-entry">sparse file.</span> A files with random organization (see random access) which contains areas which were never initialized. A sparse file might have an End Of File mark of 26 megabytes but only contain several hundred bytes.
</div>
<div class="Description">
<span class="Description-entry">state machine.</span> A process (in software or hardware) which defines a unique target state, given an input state and certain conditions. A state machine approach is used in the ProDOS BASIC Interpreter to keep track of its video intercepts and by the hardware on the disk controller card to process disk data.
</div>
<div class="Description">
<span class="Description-entry">strobe.</span> The act of triggering an I/O function by momentarily referencing a special I/O address. Strobing $C030 produces a click on the speaker. Also called &ldquo;toggling&rdquo;.
</div>
<div class="Description">
<span class="Description-entry">subroutine.</span> A program whose function is required repeatedly during execution, and therefore is called by a main program in several places.
</div>
<div class="Description">
<span class="Description-entry">system disk.</span> A ProDOS volume which contains the system files necessary to allow ProDOS to be booted into memory. Normally, the PRODOS and BASIC.SYSTEM files are necessary. A STARTUP program may also be present. 
</div>
<div class="Description">
<span class="Description-entry">system program.</span> A ProDOS program, written in machine language, which acts as an intermediary between the user and the ProDOS Kernel. BASIC.SYSTEM, FILER, and CONVERT are all examples of System Programs. See also interpreter and BI.
</div>
<div class="Description">
<span class="Description-entry">table.</span> A collection of data entries, having a similar format, residing in memory. Each entry might contain the name of a program and its address. For examples. A &ldquo;lookup&rdquo; can be performed on such a table to locate any given program by name. 
</div>
<div class="Description">
<span class="Description-entry">toggle.</span> The act of triggering an I/O function by momentarily referencing a special I/O address. Toggling $C030 produces a click on the speaker. Also called &ldquo;strobe&rdquo;.
</div>
<div class="Description">
<span class="Description-entry">tokens.</span> A method where human recognizable words may be coded to single binary bye values for memory compression and faster processing. BASIC statements are tokenized, where hex codes are assigned to words like IF, PRINT, and END.
</div>
<div class="Description">
<span class="Description-entry">track.</span> One complete circular path of magnetic storage on a diskette. There are 35 concentric tracks on an Apple diskette.
</div>
<div class="Description">
<span class="Description-entry">translate table.</span> A table of single byte codes which are to replace input codes on a one-for-one basis. A translate table is used to convert from 6-bit codes to disk codes.
</div>
<div class="Description">
<span class="Description-entry">tree.</span> A ProDOS file which requires several index blocks (131,073 to 16,777,216 bytes of data). See also index block, seedling, and sapling.
</div>
<div class="Description">
<span class="Description-entry">TTL.</span> Transistor to Transistor Logic. A standard for the interconnection of integrated circuits which also defines the voltages which represent 0’s and 1’s.
</div>
<div class="Description">
<span class="Description-entry">unlocked.</span> A file which allows all types of access (READ, WRITE, DELETE, RENAME, etc.). See also locked.
</div>
<div class="Description">
<span class="Description-entry">utility.</span> A program which is used to maintain, or assist in the development of, other programs or disk files.
</div>
<div class="Description">
<span class="Description-entry">vector.</span> A collection of pointers or JMP instructions at a fixed location in memory which allows access to a relocatable program or data.
</div>
<div class="Description">
<span class="Description-entry">volume.</span> An identification for a diskette, disk platter, or cassette, containing one or more files.
</div>
<div class="Description">
<span class="Description-entry">Volume Directory.</span> The first directory on a disk volume. Also called the &ldquo;root&rdquo; directory. All other directories must be reached by first reading the Volume Directory.
</div>
<div class="Description">
<span class="Description-entry">warmstart.</span> A restart of a program which retains, as much as is possible, the work which was in progress at the time.
</div>
<div class="Description">
<span class="Description-entry">ZAP.</span> From the IBM mainframe utility SUPERZAP. A program which allows updates to a disk at a byte level, using hexadecimal.
</div>
<div class="Description">
<span class="Description-entry">zero page.</span> The first 256 bytes of memory in a 6502 based machine. Zero page locations have special significance to the central processor, making their management and assignment critical.
</div>
<div class="Unindented">
<span class="unknown">\end</span>multicols
</div>

</div>
</body>
</html>
